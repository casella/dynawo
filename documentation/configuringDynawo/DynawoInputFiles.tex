%% Except where otherwise noted, content in this documentation is Copyright (c)
%% 2015-2019, RTE (http://www.rte-france.com) and licensed under a
%% CC-BY-4.0 (https://creativecommons.org/licenses/by/4.0/)
%% license. All rights reserved.

\documentclass[a4paper, 12pt]{report}

% Latex setup
\input{../latex_setup.tex}

\begin{document}

\title{Configure \Dynawo}
\date\today

\maketitle
\tableofcontents

\chapter[Configure Dynawo]{Configure \Dynawo}

\section{Overview}

The following section will provide information on:
\begin{itemize}
\item How to create the input files in order to simulate a given test case;
\item How to configure the input files in order to get the  necessary output files to analyse the obtained results;
\end{itemize}

The list of input files and the most important output files are summarized in the figure below:

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{../resources/DynawoModelSolver.png}
\caption{\Dynawo input and output files}
\end{figure}

\subsection[Dynawo inputs]{\Dynawo inputs}

To run a simulation, \Dynawo needs most of the time four input files:
\begin{itemize}
\item A file providing the simulation settings: the jobs file (\textbf{.jobs} extension);
\item A file providing the static description of the test grid to simulate: the iidm file (\textbf{.iidm} extension);
\item A file providing the dynamic description of the test grid to simulate: the dynamic data file (\textbf{.dyd} extension);
\item A file providing the needed parameters of the simulation: the parameter file (\textbf{.par} extension);
\end{itemize}
The iidm file can be optional for small test cases where the whole system is represented in the dyd file (see paragraph \ref{sec:Run a simulation with no iidm file}).
Other files are mandatory. \\

Others optional files can be given as inputs:
\begin{itemize}
\item A file providing the list of the variables to plot at the end of the simulation: the curves file (\textbf{.crv} extension);
\item A file providing the final values for a list of variables: the final state value file (\textbf{.fsv} extension);
\item A file providing the list of the criteria to check during the simulation: the criteria file (\textbf{.crt} extension);
\item A file providing an initial state for the dynamic variables, provided by a previous \Dynawo simulation: the initial state file (\textbf{.dmp} extension);
\end{itemize}

All jobs, iidm, dyd, par, crv, fsv and crt files are XML files.
Their extension can also be .xml.
For each file, there is an associated xsd file used to validate the xml file and to check that it respects a certain format.
The xsd file defines which elements and attributes are permitted and in which order.
In that sense, they can help the user write or modify one or several input files.
The different xsd files are to be found in the install directory in \path{dynawo/share/xsd}.

\begin{itemize}
\item jobs.xsd for the jobs file;
\item dyd.xsd for the dyd file;
\item parameters.xsd for the par file;
\item curvesInput.xsd for the crv file;
\item finalStateValuesInput.xsd for the fsv file;
\item criteria.xsd for the crt file;
\end{itemize}

The iidm.xsd is directly located in the install directory of the IIDM library and can be found in \path{share/iidm/xsd}.

\subsection[Dynawo outputs]{\Dynawo outputs}

After a simulation that went well, \Dynawo generates the following output files:
\begin{itemize}
\item A file providing the chronological list of events that happened during the simulation: component connection, disconnection, automata activation, etc (timeline.txt).
\item A file providing the list of constraints that happened in the network during the simulation (constraints.txt);
\item A file providing the static state of the network at the end of the simulation (output.iidm). This iidm file can be used to start another dynamic simulation;
\item A binary file providing the dynamic state of the network at the end of the simulation (output.dmp). This file can be used to start another dynamic simulation;
\item A file providing the value of the desired variables at each time step in order to visualize their evolution through time (curves.crv);
\item A file providing the value of the desired variables at the final time step (finalStateValues.fsv);
\item A file providing the static ids of the nodes that were disconnected during the simulation (lostEquipments.leq);
\item A file providing information about how the simulation went (dynawo.log). This log file contains error messages if the simulation crashed;
\item Files providing the variables values after initialization for each model. The values can be printed after local (or individual model) initialization or global (or system) initialization.
\end{itemize}

The input jobs file should be configured properly in order to give access to all these outputs (see paragraph \ref{sec:Configure the jobs outputs}).

\section[Dynawo input files]{\Dynawo input files}

The following sections get into more details regarding the five input files and give some examples based on the non-regression test IEEE14 present in the \Dynawo repository. \\
Warning: the following example files are extracted from IEEE14 case in \Dynawo and might not be complete, hence not work as they are presented here.

\subsection{jobs file}

\subsubsection{Overview}
The jobs file gathers information about the solver to use, the models to use, the simulation characteristics and the outputs wanted.

Here is an example on a jobs file:
\lstinputlisting[language=XML, morekeywords={solver, modeler, simulation, outputs},title=jobs file example]{../resources/syntaxExample/syntaxExample.jobs}

In this example, we want to simulate a 100 second scenario on IIDM network
IEEE14.iidm described by dynamic models included in IEEE14.dyd with a precision
of $10^{-6}$. A criteria file with stop conditions has been specified.
The models compiled by \Dynawo will be exported in \path{outputs/compilation} directory. Network parameters are stored in IEEE14.par file, set 18. \\

The solver used is the simplified solver, and its parameters are described in solvers.par file, set 1. \\

At the end of the simulation, the user will have the possibility to plot the different variables listed in IEEE14.crv, thanks to a csv file generated by \Dynawo in \path{outputs/curves} directory. \\

The chronology of events that happened during the simulation will also be
available in a text file in \path{outputs/timeline} directory. Also, every 10
iterations the current time of the simulation will be dumped in a
temporary file in \path{outputs/} directory to offer the possibility to follow the advancement of Dynawo during the simulation.

Absolute and relative paths can be used and mixed in a single jobs file. Relative paths refer to the directory where the jobs file is located.

\subsubsection{jobs xml element}

The \textit{jobs} element contains one or more \textit{job} elements. Each job describes a simulation that will be run sequentially by \Dynawo, as shown below.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c | c }
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}& \textbf{{Section}}\\
\midrule
\small{job} & \small{Unlimited} & \small{Description of a simulation that will be run by \Dynawo}  & \ref{DynawoInputFiles_inputs_jobs_job_tag}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{jobs} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={name}]
<jobs xmlns="http://www.rte-france.com/dynawo">
  <job name="MyFirstJOB">
    ...
  </job>
  <job name="MySecondJOB">
    ...
  </job>
</jobs>
\end{lstlisting}

\subsubsection{jobs/job element}
\label{DynawoInputFiles_inputs_jobs_job_tag}

A \textit{job} provides all the required data for \Dynawo to run a simulation.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{name} & \small{Required} & \small{Name of the current job (for logs)}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{job} tag}
\end{table}

\begin{table}[H]
\center
\begin{tabular}{ l | c | c | c }
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}& \textbf{{Section}}\\
\midrule
\rowcolor{white}
\small{solver} & \small{1 (required)} & \small{Description of the solver}  & \ref{DynawoInputFiles_inputs_jobs_job_solver}\\
\rowcolor{gray!10}
\small{modeler} & \small{1 (required)} & \small{Description of the power system}  & \ref{DynawoInputFiles_inputs_jobs_job_modeler}\\
\rowcolor{white}
\small{simulation} & \small{1 (required)} & \small{Description of the simulation parameters}  &  \ref{DynawoInputFiles_inputs_jobs_job_simulation}\\
\rowcolor{gray!10}
\small{outputs} & \small{0-1 (optional)} & \small{Description of the expected outputs of the simulation}  &  \ref{DynawoInputFiles_inputs_jobs_job_outputs}\\
\rowcolor{white}
\small{localInit} & \small{0-1 (optional)} & \small{Parameters of the solver during power system initialization}  & \ref{DynawoInputFiles_inputs_jobs_job_localInit}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{job} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={name}]
  <dyn:job name="MyFirstJOB">
    <dyn:solver .../>
    <dyn:modeler ...>
      ...
    </dyn:modeler>
    <dyn:simulation ...>
      ...
    </dyn:simulation>
    <dyn:outputs ...>
      ...
    </dyn:outputs>
    <dyn:localInit .../>
  </dyn:job>
\end{lstlisting}

\subsubsection{jobs/job/solver element}
\label{DynawoInputFiles_inputs_jobs_job_solver}

The job \textit{solver} element file specifies the solver to use for the simulation. In \Dynawo two solvers are available:
\begin{itemize}
\item the simplified solver (fixed time step solver): dynawo\_SolverSIM;
\item the IDA solver (variable time step solver): dynawo\_SolverIDA;
\end{itemize}

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{lib} & \small{Required} & \small{Name of the solver to use (dynawo\_SolverIDA or dynawo\_SolverSIM)}\\
\rowcolor{gray!10}
\small{parFile} & \small{Required} & \small{Path to the file containing the solver parameters (relative to jobs filepath)}\\
\rowcolor{white}
\small{parId} & \small{Required} & \small{Id of the parameter set containing the solver parameters}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{solver} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={lib}]
<job name="MyJOBIDA">
  <solver lib="dynawo_SolverIDA" parFile="MyPAR.xml" parId="0"/>
  ...
</job>
<job name="MyJOBSIM">
  <solver lib="dynawo_SolverSIM" parFile="MyPAR.xml" parId="1"/>
  ...
</job>
\end{lstlisting}

Please refer to \ref{DynawoInputFiles_inputs_par_solver} for a description of solver parameters.

\subsubsection{jobs/job/modeler element}
\label{DynawoInputFiles_inputs_jobs_job_modeler}

The job \textit{modeler} element file describes the power system that will be simulated.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{compileDir} & \small{Required} & \small{Path where the models compiled on-the-fly will be stored}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{modeler} tag}
\end{table}

\begin{table}[H]
\center
\begin{tabular}{ l | c | c | c }
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}& \textbf{{Section}}\\
\midrule
\rowcolor{white}
\small{network} & \small{0-1 (optional)} & \small{Description of static model (IIDM)}  & \ref{DynawoInputFiles_inputs_jobs_job_modeler_network}\\
\rowcolor{gray!10}
\small{dynModels} & \small{Unlimited (required)} & \small{Description of dynamic models}  & \ref{DynawoInputFiles_inputs_jobs_job_modeler_dynModels}\\
\rowcolor{white}
\small{initialState} & \small{0-1 (optional)} & \small{Description of the initial state to use for the simulation}  & \ref{DynawoInputFiles_inputs_jobs_job_modeler_initialState}\\
\rowcolor{gray!10}
\small{precompiledModels} & \small{1 (required)} & \small{Description of the pre-assembled models library to use}  & \ref{DynawoInputFiles_inputs_jobs_job_modeler_precompiledModels}\\
\rowcolor{white}
\small{modelicaModels} & \small{1 (required)} & \small{Description of the Modelica models to use}  & \ref{DynawoInputFiles_inputs_jobs_job_modeler_modelicaModels}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{modeler} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={network, dynModels, initialState, precompiledModels, modelicaModels}]
<job name="MyJOB">
  ...
  <modeler compileDir="outputs/compilation">
      <network .../>
      <dynModels .../>
      <initialState .../>
      <precompiledModels .../>
      <modelicaModels .../>
  </modeler>
  ...
</job>
\end{lstlisting}

\subsubsection{jobs/job/modeler/network element}
\label{DynawoInputFiles_inputs_jobs_job_modeler_network}

The \textit{network} element describes the static model to use during the simulation and the parameters of the default dynamic models (dynamic model used for component not described in the dyd file).

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{iidmFile} & \small{Required} & \small{Path to the input IIDM file (relative to jobs filepath)}\\
\rowcolor{gray!10}
\small{parFile} & \small{Required} & \small{Path to the file containing the network parameters (relative to jobs filepath)}\\
\rowcolor{white}
\small{parId} & \small{Required} & \small{Id of the parameter set containing the network parameters}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{network} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={network}]
<job name="MyJOB">
  ...
  <modeler compileDir="outputs/compilation">
      <network iidmFile="MyIIDM.iidm" parFile="MyPAR.par" parId="NETWORK"/>
      ...
  </modeler>
  ...
</job>
\end{lstlisting}

Please refer to \ref{DynawoInputFiles_inputs_iidm} for a description of the IIDM file and to \ref{DynawoInputFiles_inputs_par_network} for a description of network parameters.\\

This element is optional in a job. Please refer to \ref{sec:Run a simulation with no iidm file} for a description of how to run a simulation with no static model.

\subsubsection{jobs/job/modeler/dynModels element}
\label{DynawoInputFiles_inputs_jobs_job_modeler_dynModels}

The \textit{dynModels} element describes the dynamic models to use during the simulation.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{dydFile} & \small{Required} & \small{Path to the input dynamic model description file (relative to jobs filepath)}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{dynModels} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={network}]
<job name="MyJOB">
  ...
  <modeler compileDir="outputs/compilation">
      ...
      <dynModels dydFile="MyDYD.dyd"/>
      ...
  </modeler>
  ...
</job>
\end{lstlisting}

Please refer to \ref{DynawoInputFiles_inputs_dyd} for a description of the DYD file.

\subsubsection{jobs/job/modeler/initialState element}
\label{DynawoInputFiles_inputs_jobs_job_modeler_initialState}

The \textit{initialState} element describes the initial state to use during the simulation.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{file} & \small{Required} & \small{Path to the initial state file (relative to jobs filepath)}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{initialState} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={network}]
<job name="MyJOB">
  ...
  <modeler compileDir="outputs/compilation">
      ...
      <initialState file="initialState.dmp"/>
      ...
  </modeler>
  ...
</job>
\end{lstlisting}

Please refer to \ref{DynawoInputFiles_inputs_howto_jobs_job_modeler_initialState} for a description of how to use this element to restart a simulation from the final state of a previous simulation.

\subsubsection{jobs/job/modeler/precompiledModels element}
\label{DynawoInputFiles_inputs_jobs_job_modeler_precompiledModels}

The \textit{precompiledModels} element describes the pre-assembled models library (models compiled before the simulation, either provided with \Dynawo distribution or custom models compiled by user)
to use during the simulation.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{useStandardModels} & \small{Required} & \small{true if the simulation uses the pre-assembled}\\
 &  & \small{models library provided with \Dynawo)}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{precompiledModels} tag}
\end{table}

\begin{table}[H]
\center
\begin{tabular}{ l | c | c}
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{directory} & \small{Unlimited (optional)} & \small{Path to a directory containing custom pre-assembled models}\\
 &  &  \small{(relative to jobs filepath) and whether}\\
 &  &  \small{this directory should be explored recursively or not}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{precompiledModels} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={precompiledModels}]
<job name="MyJOB">
  ...
  <modeler compileDir="outputs/compilation">
      ...
      <precompiledModels useStandardModels="true">
        <directory path="MyPreassembledFolder" recursive="true"/>
      </precompiledModels>
      ...
  </modeler>
  ...
</job>
\end{lstlisting}

\subsubsection{jobs/job/modeler/modelicaModels element}
\label{DynawoInputFiles_inputs_jobs_job_modeler_modelicaModels}

The \textit{modelicaModels} element describes the Modelica models library (models used during on-the-fly compilation)
to use during the simulation.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{useStandardModels} & \small{Required} & \small{true if the simulation uses the Modelica}\\
 &  & \small{models library provided with \Dynawo)}\\
\rowcolor{gray!10}
\small{modelExtension} & \small{Optional} & \small{files extension (``.mo'' by default)}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{modelicaModels} tag}
\end{table}

\begin{table}[H]
\center
\begin{tabular}{ l | c | c}
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{directory} & \small{Unlimited (optional)} & \small{Path to a directory containing Modelica models}\\
 &  &  \small{(relative to jobs filepath) and whether}\\
 &  &  \small{this directory should be explored recursively or not}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{modelicaModels} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={precompiledModels}]
<job name="MyJOB">
  ...
  <modeler compileDir="outputs/compilation">
      ...
      <modelicaModels useStandardModels="true" modelExtension=".txt">
        <directory path="MyModelicaFolder" recursive="true"/>
      </modelicaModels>
      ...
  </modeler>
  ...
</job>
\end{lstlisting}

\subsubsection{jobs/job/simulation element}
\label{DynawoInputFiles_inputs_jobs_job_simulation}

The job \textit{simulation} element describes the main attributes of the simulation to be run, the list of criteria to check and the time step between 2 criteria check.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{startTime} & \small{Required} & \small{Start time of the simulation}\\
\rowcolor{gray!10}
\small{stopTime} & \small{Required} & \small{Stop time of the simulation}\\
\rowcolor{white}
\small{criteriaStep} & \small{Optional} & \small{Minimum time between two criteria check}\\
\rowcolor{gray!10}
\small{precision} & \small{Optional} & \small{Float precision during comparisons (default: 1e-6)}\\
\rowcolor{white}
\small{timeout} & \small{Optional} & \small{Maximum elapsed time after which the simulation will stop (in s)}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{simulation} tag}
\end{table}

\begin{table}[H]
\center
\begin{tabular}{ l | c | c | c }
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}& \textbf{{Section}}\\
\midrule
\rowcolor{white}
\small{criteria} & \small{Unlimited (optional)} & \small{Path to criteria files}  & \ref{DynawoInputFiles_inputs_crt}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{simulation} tag}
\end{table}


When no criteria is specified, simulation will stop at the stop time given by
the user. Otherwise, the simulation could stop before the stop
time if a criterion is not respected.

\begin{lstlisting}[language=XML, morekeywords={network, dynModels, initialState, precompiledModels, modelicaModels}]
<job name="MyJOB">
  ...
  <simulation startTime="0" stopTime="30" criteriaStep="5" precision="1e-4" timeout="1000">
    <criteria criteriaFile="MyCriteraFile.crt">
    <criteria criteriaFile="MyOtherCriteraFile.crt">
  </simulation>
  ...
</job>
\end{lstlisting}

\subsubsection{jobs/job/outputs element}
\label{DynawoInputFiles_inputs_jobs_job_outputs}

The optional \textit{outputs} element describes the outputs that \Dynawo should create during the simulation.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{directory} & \small{Required} & \small{Directory path where the outputs will be written}\\
 & & \small{(relative to jobs filepath)}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{outputs} tag}
\end{table}

\begin{table}[H]
\center
\begin{tabular}{ l | c | c | c }
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}& \textbf{{Section}}\\
\midrule
\rowcolor{white}
\small{dumpInitValues} & \small{0-1 (optional)} & \small{Dump all variables and parameters}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_dumpInitValues}\\
 &  & \small{values during initialization}  & \\
\rowcolor{gray!10}
\small{dumpFinalValues} & \small{0-1 (optional)} & \small{Dump all variables and parameters}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_dumpFinalValues}\\
\rowcolor{gray!10}
 &  & \small{values after simulation}  & \\
\rowcolor{white}
\small{constraints} & \small{0-1 (optional)} & \small{Dump constraints}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_constraints}\\
\rowcolor{gray!10}
\small{timeline} & \small{0-1 (optional)} & \small{Dump timeline}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_timeline}\\
\rowcolor{white}
\small{timetable} & \small{0-1 (optional)} & \small{Dump \Dynawo advancement on-the-fly}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_timetable}\\
\rowcolor{gray!10}
\small{finalState} & \small{0-1 (optional)} & \small{Dump the final state as IIDM or binary file}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_finalState}\\
\rowcolor{white}
\small{curves} & \small{0-1 (optional)} & \small{Dump curves}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_curves}\\
\rowcolor{gray!10}
\small{finalStateValues} & \small{0-1 (optional)} & \small{Dump specific variables and parameters}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_finalStateValues}\\
\rowcolor{gray!10}
 & & \small{values after simulation}  & \\
\rowcolor{white}
\small{lostEquipments} & \small{0-1 (optional)} & \small{Dump lost equipments list}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_lostEquipments}\\
\rowcolor{gray!10}
\small{logs} & \small{0-1 (optional)} & \small{Description of logs to dump}  & \ref{DynawoInputFiles_inputs_jobs_job_outputs_logs}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{outputs} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={network}]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <dumpInitValues .../>
      <dumpFinalValues .../>
      <constraints .../>
      <timeline .../>
      <timetable .../>
      <finalState .../>
      <curves .../>
      <lostEquipments .../>
      <logs>
        ...
      </logs>
    </outputs>
  ...
</job>
\end{lstlisting}

\subsubsection{jobs/job/outputs/dumpInitValues element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_dumpInitValues}

the user can have access to the values of the variables and parameters of the initialization stages (local and/or global) by adding the element \textit{dumpInitValues} in the outputs section in the jobs file.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{global} & \small{Required} & \small{'true' to dump value after global initialization}\\
\rowcolor{gray!10}
\small{local} & \small{Required} & \small{'true' to dump value after local initialization}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{dumpInitValues} tag}
\end{table}


\begin{lstlisting}[language=XML, morekeywords={dumpInitValues},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <dumpInitValues local="true" global="true"/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'initValues' in the outputs directory.

\subsubsection{jobs/job/outputs/dumpFinalValues element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_dumpFinalValues}

the user can have access to the values of the variables and parameters at the end of the simulation by adding the element \textit{dumpFinalValues} in the outputs section in the jobs file.


\begin{lstlisting}[language=XML, morekeywords={dumpFinalValues},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <dumpFinalValues/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'finalValues' in the outputs directory.

\subsubsection{jobs/job/outputs/constraints element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_constraints}

the user can have access to the list of constraints that happened during the simulation by adding the element \textit{constraints} in the outputs section in the jobs file, and by specifying the export mode.
Two export modes are available for constraints: TXT or XML.

\begin{lstlisting}[language=XML, morekeywords={constraints},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <constraints exportMode="TXT"/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'constraints' in the outputs directory.

\subsubsection{jobs/job/outputs/timeline element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_timeline}

the user can have access to the list of events that happened during the simulation and the instant of their occurrence by adding the element \textit{timeline}
in the outputs section in the jobs file, and by specifying the export mode.\\
Three export modes are available for the timeline: TXT, XML or CSV.\\
It is also possible to automatically filter the timeline by removing duplicated events and opposed events that happen during the same timestep.


\begin{lstlisting}[language=XML, morekeywords={timeline},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <timeline exportMode="TXT" filter="true"/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'timeLine' in the outputs directory.

\subsubsection{jobs/job/outputs/timetable element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_timetable}


The user can follows the advancement of \Dynawo during the simulation by adding the element \textit{timetable}
in the outputs section in the jobs file, and by specifying the number of iterations between two dumps in the file.\\

\begin{lstlisting}[language=XML, morekeywords={timetable},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <timetable step="10"/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a file with a name prefixed by 'dynawoexec' in the outputs directory.

\subsubsection{jobs/job/outputs/finalState element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_finalState}

The user have access to the final state of the simulation by adding the element \textit{finalState}
in the outputs section in the jobs file, and by specifying the type of the required file.\\
Two types are available: iidm file and dump file (binary).\\
The iidm output file contains the static data of the network at the end of the simulation.
The dump file is a binary file that contains the value of all dynamic variables and derivatives at the end of the simulation and that enables to restart another simulation from this operating point.


\begin{lstlisting}[language=XML, morekeywords={finalState},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <finalState exportIIDMFile="true" exportDumpFile="true"/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'finalState' in the outputs directory.

\subsubsection{jobs/job/outputs/curves element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_curves}

The user have access to all the values taken by a set of variables during the simulation by adding the element \textit{curves}
in the outputs section in the jobs file, by specifying the type of the required file and optionally a step on simulation iteration or on simulation time (in seconds).\\
Two export modes are available for curves export: CSV or XML.\\
It's impossible to define both an iterationStep and a timeStep.


\begin{lstlisting}[language=XML, morekeywords={curves},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <curves inputFile="MyCurves.crv" exportMode="CSV"/>
    </outputs>
  ...
</job>
<job name="MyJOB2">
  ...
    <outputs directory="outputs">
      <curves inputFile="MyCurves.crv" exportMode="CSV" iterationStep="8"/>
    </outputs>
  ...
</job>
<job name="MyJOB3">
  ...
    <outputs directory="outputs">
      <curves inputFile="MyCurves.crv" exportMode="CSV" timeStep="0.4"/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'curves' in the outputs directory.

\subsubsection{jobs/job/outputs/finalStateValues element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_finalStateValues}

the user can have access to the final values of a specific list of variables or parameters at the end of the simulation by adding the element
\textit{finalStateValues} in the outputs section in the jobs file, and by specifying the export mode.\\
Three export modes are available for the final state values: TXT, XML or CSV.\\.


\begin{lstlisting}[language=XML, morekeywords={finalState},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <finalStateValues inputFile="MyFinalStateValues.fsv" exportMode="CSV"/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'finalStateValues' in the outputs directory.

\subsubsection{jobs/job/outputs/lostEquipments element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_lostEquipments}

the user can have access to the list of nodes that were initially connected and that are disconnected at the end of the simulation by adding the element
\textit{lostEquipments} in the outputs section in the jobs file.


\begin{lstlisting}[language=XML, morekeywords={finalState},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <lostEquipments/>
    </outputs>
  ...
</job>
\end{lstlisting}

The results files will be generated in a directory named 'lostEquipments' in the outputs directory.

\subsubsection{jobs/job/outputs/logs element}
\label{DynawoInputFiles_inputs_jobs_job_outputs_logs}

The user can have access to different log files that give information about the execution of the compilation and the simulation,
and that could help him in case of failure. The main log file corresponds to the appender with no tag named ``dynawo.log'' in the example below.

\begin{lstlisting}[language=XML, morekeywords={logs},numbers=none]
<job name="MyJOB">
  ...
    <outputs directory="outputs">
      <logs>
        <appender tag="" file="dynawo.log" lvlFilter="DEBUG"/>
        <appender tag="NETWORK" file="network.log" lvlFilter="DEBUG"/>
        <appender tag="MODELER" file="modeler.log" lvlFilter="DEBUG"/>
        <appender tag="COMPILE" file="compile.log" lvlFilter="DEBUG"/>
        <appender tag="PARAMETERS" file="param.log" lvlFilter="DEBUG"/>
        <appender tag="VARIABLES" file="variables.log" lvlFilter="DEBUG"/>
        <appender tag="EQUATIONS" file="equations.log" lvlFilter="DEBUG"/>
      </logs>
   </outputs>
  ...
</job>
\end{lstlisting}

For each ``appender'', a format could be configured to set how the log should be printed. By default, the format of the ``appender'' is the following:
\begin{lstlisting}[numbers=none]
%Y-%m-%d %H:%M:%S | <lvlFilter> | log
\end{lstlisting}

where ``lvlFilter'' is used to filter the trace exported by giving the minimum level exported. For example, if a level filter of ``WARN'' is set, only logs declared as ``WARN'' or ``ERROR'' will be exported. \\

The available filters are: DEBUG, INFO, WARN, ERROR.\\

The results files will be generated in a directory named 'logs' in the outputs directory.

\subsubsection{jobs/job/localInit element}
\label{DynawoInputFiles_inputs_jobs_job_localInit}

The optional \textit{localInit} element describes the solver parameters to use during the initialization.
if this element is not provided, the same parameters as the \textit{solver} element (see \ref{DynawoInputFiles_inputs_jobs_job_solver}) will be used.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}}\\
\midrule
\rowcolor{white}
\small{parFile} & \small{Required} & \small{Path to the file containing the initialization}\\
 &  & \small{solver parameters (relative to jobs filepath)}\\
\rowcolor{gray!10}
\small{parId} & \small{Required} & \small{Id of the parameter set containing the initialization solver parameters}\\
\bottomrule
\end{tabular}
\caption{attributes of \textit{localInit} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={network}]
<job name="MyJOB">
  ...
  <localInit parFile="MyPAR.par" parId="LocalSolverParamSet"/>
  ...
</job>
\end{lstlisting}

% TODO CHECK IF THIS IS THE GOOD LOCATION
The list of local initialization solver parameters the user is as follows :

\begin{table}[H]
\center
\begin{tabular}{ l | c | c | c }
\toprule
\textbf{{Name}} & \textbf{{Type}} & \textbf{{Description}} & \textbf{{Default value}}\\
\midrule
\rowcolor{white}
\small{mxiter} & \small{int} & \small{maximum number of nonlinear iterations} & \small{30} \\
\rowcolor{gray!10}
 &  & \small{stopping tolerance on L2-norm} &  \\
\rowcolor{gray!10}
\multirow{-2}{*}{\small{fnormtol}} & \multirow{-2}{*}{\small{double}} & \small{of function value} & \multirow{-2}{*}{\small{1e-4}} \\
\rowcolor{white}
\small{initialaddtol} & \small{double} & \small{stopping tolerance at initialization} & \small{0.1} \\
\rowcolor{gray!10}
\small{scsteptol} & \small{double} & \small{scaled step length tolerance} & \small{1e-4} \\
\rowcolor{white}
\small{mxnewtstep} & \small{double} & \small{maximum allowable scaled step length} & \small{100000} \\
\rowcolor{gray!10}
 &  & \small{maximum number of nonlinear iterations} &  \\
\rowcolor{gray!10}
\small{msbset} & \small{int} & \small{that may be performed between calls to} & \small{0} \\
\rowcolor{gray!10}
 &  & \small{the linear solver setup routine} &  \\
 \rowcolor{gray!10}
\rowcolor{white}
\small{printfl} & \small{int} & \small{level of verbosity of output (from 0 to 3)} & \small{0} \\
\bottomrule
\end{tabular}
\caption{Local initialization solver parameters}
\end{table}

Here is an example of a par file containing local initialization solver parameters :

\begin{lstlisting}[language=XML]
<set id="1">
  <par type="INT" name="mxiter" value="30"/>
  <par type="DOUBLE" name="fnormtol" value="1e-4"/>
  <par type="DOUBLE" name="initialaddtol" value="0.1"/>
  <par type="DOUBLE" name="scsteptol" value="1e-4"/>
  <par type="DOUBLE" name="mxnewtstep" value="100000"/>
  <par type="INT" name="msbset" value="0"/>
  <par type="INT" name="printfl" value="0"/>
</set>
<set id="2">
  <par type="INT" name="mxiter" value="25"/>
  <par type="DOUBLE" name="fnormtol" value="1e-6"/>
</set>
\end{lstlisting}

\subsection{iidm file}
\label{DynawoInputFiles_inputs_iidm}

The iidm (iTesla Internal Data Model) file represents the network to simulate with a static representation: it lists all the components present in the network and how they are connected. \\

Basically, the iidm file is composed of:
\begin{itemize}
\item the substations, which contain one or more voltage levels, which themselves contain buses, loads, generators, etc;
\item the branches (lines and transformers) that connect buses defined in the voltage levels;
\end{itemize}

Here is an example of an iidm file (extraction from IEEE14.iidm):
\lstinputlisting[language=XML, morekeywords={voltageLevel, line, bus, switch, load, generator, bus1, bus2}, title=iidm file example]{../resources/syntaxExample/syntaxExample.iidm}

In this example, the network is composed of only two voltage levels connected through one line. \\

The first voltage level (\_BUS\_\_\_10\_VL) has one bus (\_BUS\_\_\_10\_TN) and one load (\_LOAD\_\_10\_EC). The second voltage level (\_BUS\_\_\_11\_VL) has also one bus (\_BUS\_\_\_11\_TN) and one load (\_LOAD\_\_11\_EC). \\

The line connects the bus \_BUS\_\_\_10\_TN of voltage level \_BUS\_\_\_10\_VL and the bus \_BUS\_\_\_11\_TN of the voltage level \_BUS\_\_\_11\_VL. \\

iidm files are very dense and can be very large in case of large systems because they provide a lot of information:
\begin{itemize}
\item the \textbf{static parameters} with their values. For example, for the line the static parameters are: the resistance (R), the reactance (X), the conductances on both sides (G1, G2) and the susceptances on both sides (B1, B2).  They are used by \Dynawo to build the network model.
\item the \textbf{load flow outputs} obtained thanks to another simulation module: the voltages amplitude and angle at each bus (V, $\theta$) and the active and reactive power at each injection point: (P, Q) for the load in this example. They are used by \Dynawo to initialize the dynamic simulation.
\item the \textbf{network topology} in the initial situation. We have seen in our example that we have information about the connection between different voltage levels through a line.
\end{itemize}

A detailled description of the iidm format can be found \href{https://www.powsybl.org/pages/documentation/grid/model/)}{in the PowSybl documentation}.


\subsection{dyd file}
\label{DynawoInputFiles_inputs_dyd}
\subsubsection{Overview}

The dyd file gathers the dynamics models to use with their characteristics and if needed, their connections. \\

Here is an example of a dyd file (extraction from IEEE14.dyd):
\lstinputlisting[language=XML, morekeywords={modelicaModel,  blackBoxModel, connect}, title=dyd file example]{../resources/syntaxExample/syntaxExample.dyd}

In this example, we have two dynamic models: load \_LOAD\_\_10\_EC and load \_LOAD\_\_11\_EC. \\

The connections between these models are written at the end of the file: the load output terminal is connected to the pin of a bus given in the iidm file. The connections between the dynamics models are provided with the keyword ``connect''. \\

Here the load models are precompiled black-box models but the dyd file can use other kind of models such as macro Modelica models assembling different unit Modelica models, or template models. See following sections for more information about the different types of models supported by the dyd file. \\

In most cases, the iidm file provides information about the network topology and the static parameters, and the dyd file provides information about the dynamic behaviour of components given in the iidm file. \\

When a static component has no equivalent in the dyd file, \Dynawo uses a default C++ model for the component. This is often the case for the lines for example. It can also be the case for any other component, but the reader should keep in mind that the default C++ models are basic and simple models. In order to obtain accurate and detailed results from a dynamic simulation, it is important to use accurate and detailed models.

\subsubsection{dynamicModelsArchitecture xml element}

%TODO

The \textit{dynamicModelsArchitecture} element contains a list of dynamic models description and how they are connected to each others.

\begin{table}[H]
\center
\begin{tabular}{ l | c | c | c }
\toprule
\textbf{{Name}} & \textbf{{Occurrences}} & \textbf{{Description}}& \textbf{{Section}}\\
\midrule
\small{job} & \small{Unlimited} & \small{Description of a simulation that will be run by \Dynawo}  & \ref{DynawoInputFiles_inputs_jobs_job_tag}\\
\bottomrule
\end{tabular}
\caption{elements of \textit{dynamicModelsArchitecture} tag}
\end{table}

\begin{lstlisting}[language=XML, morekeywords={name}]
<dynamicModelsArchitecture xmlns="http://www.rte-france.com/dynawo">
  <job name="MyFirstJOB">
    ...
  </job>
</dynamicModelsArchitecture>
\end{lstlisting}


\subsection{par file}
\label{DynawoInputFiles_inputs_par}
%TODO

The par file contains all the parameters for the simulation: the solver parameters and the dynamic models' parameters. All these parameters are gathered in sets. \\

Here is an example of a par file (extraction from IEEE14.par):
\lstinputlisting[language=XML, morekeywords={id, par, reference}, deletekeywords={type}, title=par file example]{../resources/syntaxExample/syntaxExample.par}

For each parameter, the user should give the name, the type (DOUBLE, INT, BOOL or STRING) and the value of the parameter. \\

Sometimes, the par file contains references to parameters present in the iidm file or a given par file. (see paragraph \ref{sec:Set a reference to a value stored in the iidm file}).

\subsubsection{Specific case: network parameters}
\label{DynawoInputFiles_inputs_par_network}
%TODO + check if this is the good location

\subsubsection{Specific case: solver parameters}
\label{DynawoInputFiles_inputs_par_solver}
%TODO + check if this is the good location

\subsection{crv file}
%TODO

The curves file lists all variables or parameters to plot. \\

Here is an example of a crv file (extraction from IEEE14.crv):
\lstinputlisting[language=XML, morekeywords={id},title=crv file example]{../resources/syntaxExample/syntaxExample.crv}

In this example, the curves available are the voltage amplitudes of buses \_BUS\_\_\_10\_TN and \_BUS\_\_\_10\_TN in per unit.

\subsection{fsv file}
%TODO

The input final state values file lists all variables or parameters for which we want to observe the final value. \\

Here is an example of a fsv file (extraction from IEEE14):
\lstinputlisting[language=XML, morekeywords={id},title=fsv file example]{../resources/syntaxExample/syntaxExample.fsv}

In this example, the final state values available are the voltage amplitudes of buses \_BUS\_\_\_10\_TN and \_BUS\_\_\_10\_TN in per unit.

\subsection{crt file}
\label{DynawoInputFiles_inputs_crt}
%TODO

The crt file contains all the criteria to be checked during the
simulation.
\\

Here is an example of a crt file :
\lstinputlisting[language=XML, morekeywords={criteria, parameters, component,
busCriteria, loadCriteria, generatorCriteria}, deletekeywords={type}, title=crt
file example]{../resources/syntaxExample/criteria.crt}

There are three different kinds of criteria, depending on which type of
component is targeted.

Each criteria is then associated to an id, a set of parameters and optionally a
list of component and/or a list of country.

The scope of a criteria (specified in its parameters) can be one of 'DYNAMIC' if
the criteria should be checked at every time step or 'FINAL' if the criteria
should be respected only at the final step.

An empty component list means that all the component corresponding to the specified type will be subject to this
criterion. If some components id are specified then only those components will
be subject to this criterion. Components from the list should have the same type as the
specified type (buses, loads or generators).

If some country ids are specified then only the components contained in a
substation with the same country attribute can be subject to this
criterion. Components contained in a substation with an empty country attribute
(and respecting the others conditions) will always be selected.

\subsubsection{bus Criteria}

Bus criteria should have at least one of $UMinPu$ or $UMaxPu$ specified. Only
local values can be checked (parameter type = 'LOCAL\_VALUE').
It fails when the following condition happens for any of the bus: \\
\begin{center}
$U_{bus} < UMinPu*U_n$\\
and/or\\
$U_{bus} > UMaxPu*U_n$ \\
\end{center}
the buses taken into account are the ones that satisfy the
following condition:
\begin{center}
$UNomMax \ge U_n \ge UNomMin$\\
\end{center}

$UNomMin$ and $UNomMax$ are optionals. If one of them is not
specified, the corresponding condition is not applied.

\subsubsection{load and generators Criteria}

Load or generator (generically named source below) criteria should have at least
one of $PMin$ or $PMax$ specified.
If local values was selected  (parameter type = 'LOCAL\_VALUE'), it fails when
the following condition happens for any of the source:\\
\begin{center}
$P_{source} < PMin$\\
and/or\\
$P_{source} > PMax$\\
\end{center}
If sum was selected  (parameter type = 'SUM'), it fails when the
following condition happens: \\
\begin{center}
$\sum P_{source} < PMin$\\
and/or\\
$\sum P_{source} > PMax$ \\
\end{center}
In both cases, the sources taken into account are the ones that satisfy the
following conditions:\\
\begin{center}
$UNomMax \ge U_n \ge UNomMin$\\
and\\
$UMaxPu*U_n \ge U_{source} \ge UMinPu*U_n$ \\
\end{center}

$UNomMin$, $UNomMax$, $UMinPu$ and $UMaxPu$ are optionals. If one of them is not
specified, the corresponding condition is not applied.
If several voltage levels are specified then all loads satisfying at least one of the conditions will be taken into account.

\section[Dynawo input files scenarios]{\Dynawo input files modification}

\Dynawo input files (jobs, iidm, dyd, par and crv) have been briefly described in the previous section.
This section aims at giving some specific scenarios that could happen on each file in order to help the user parametrize its inputs easily and autonomously.

\subsection{jobs file}

\subsubsection{Start a simulation from the end of another one}
\label{DynawoInputFiles_inputs_howto_jobs_job_modeler_initialState}

In order to start a simulation from the end of another simulation, the item ``initialState'' should be added in the modeler section of the job file.
This binary file contains the values of all variables and their derivatives at the end of the previous simulation and is needed to initialize the new simulation at the same operating point that the end of the previous simulation. \\
To obtain this file, use the finalState item of the outputs section (see paragraph \ref{DynawoInputFiles_inputs_jobs_job_outputs_finalState}).\\
The startTime from the \textit{simulation} element of the second job should be equals to the stop time of the first simulation.
Also, the stopTime and the potential events time in the parameters should be coherent with this startTime.

\begin{lstlisting}[language=XML, morekeywords={initialState}]
<job name="MyInitialJOB">
  ...
  <modeler compileDir="outputs/compilation">
      <dynModels dydFile="MyDyd.dyd"/>
      ...
  </modeler>
  <simulation startTime="0" stopTime="100"/>
  <outputs directory="outputs">
    <finalState exportIIDMFile="false" exportDumpFile="true"/>
  </outputs>
  ...
</job>
<job name="MySecondJOB">
  ...
  <modeler compileDir="outputs/compilation">
      <dynModels dydFile="MyDyd.dyd"/>
      <initialState file="outputs/finalState/outputState.dmp"/>
      ...
  </modeler>
  <simulation startTime="100" stopTime="130"/>
  ...
</job>
\end{lstlisting}

\subsubsection{Run a simulation with no iidm file}
\label{sec:Run a simulation with no iidm file}

It is not mandatory to provide the jobs file with an iidm file as long as the whole system is described in the dyd file.
We use this technique for small test cases such as unitary test cases with a few number of components.
In that case, all models are listed in the dyd file, as well as all connections.
Static components and topology normally defined in the iidm file should consequently be defined in the dyd file (buses, lines, etc).


\subsection{dyd file}

Different types of dynamic models can be used by \Dynawo and specified in the dyd file:
\begin{itemize}
\item Black-box models;
\item Modelica models;
\item Template models;
\end{itemize}

The following subsections explain how to use these models and how to write the dyd file in the different cases.

\subsubsection{Use a black-box model}

Black box models are precompiled black-box libraries. In order to use a black box model, the user should specify the model library, the associated par file and the parameters' set.
\begin{lstlisting}[language=XML, morekeywords={lib},numbers=none]
<blackBoxModel id="Model" lib="MODEL_LIB.so" parFile="MyPar.par" parId="5">
\end{lstlisting}

The models libraries are stored in the install directory in \path{dynawo/ddb}.

\subsubsection[Use a Modelica model from Dynawo library]{Use a Modelica model from \Dynawo library}

Several Modelica models are included in the \Dynawo Modelica library. Most of the time, the Modelica models used by the dynamic simulation are present in this library. To use one of these models, the user should specify the name of the dynamic and the init models in the Modelica library, the associated par file and the parameters' set.

\begin{lstlisting}[language=XML, morekeywords={name, initName}]
<modelicaModel id="MacroModel">
  <unitDynamicModel id="Model1" name="Model1" initName="Model1_INIT" parFile="MyPar.par" parId="2"/>
</modelicaModel>
\end{lstlisting}

The name of the model should include the whole path through the library, for example for a transformer: Dynawo.Electrical.Branches.Transformer.

\subsubsection[Use a Modelica model not in Dynawo Library]{Use a Modelica model not in \Dynawo Library}

To use a Modelica model that is not in the library, the user should provide the path to the dynamic and the init models to use. To do so, two attributes should be added to the ``unitDynamicModel'' item: ``moFile'' and ``initFile''.

\begin{lstlisting}[language=XML, morekeywords={moFile, initFile}]
<modelicaModel id="MacroModel">
  <unitDynamicModel id="MyModel" name="MyModel" moFile="myDirectory/MyModel.mo" initFile="myDirectory/MyModel_INIT.mo" parFile="MyPar.par" parId="1"/>
</modelicaModel>
\end{lstlisting}

\subsubsection{Assemble unit Modelica models in a macro model}

In the dyd file, several ``unitDynamicModel'' can be assembled to build a macro model. To define a macro model, the user should list in the ``modelicaModel'' section the different ``unitDynamicModel'' present and their connections. The connections between the dynamic models are provided with the keyword ``connect'', and the connections between the initialization models are provided with the keyword ``initConnect"".

\begin{lstlisting}[language=XML, morekeywords={unitDynamicModel, connect, initConnect}]
<modelicaModel id="MacroModel">
  <unitDynamicModel id="Model1" name="Model1" initName="Model1_INIT" parFile="MyPar.par" parId="2"/>
  <unitDynamicModel id="Model2" name="Model2" initName="Model2_INIT" parFile="MyPar.par" parId="3"/>
  <connect id1="Model1" var1="var1" id2="Model2" var2="var1"/>
  <initConnect id1="Model1" var1="var1" id2="Model2" var2="var1"/>
</modelicaModel>
\end{lstlisting}

We use this technique for example to assemble the physical model of a generator with the models of its regulations: the result is a macro model of a generator with its controllers.

\subsubsection{Use a template model}

Template model enables the user to define a macro model thanks to unit Modelica models (see section "How to assemble unit Modelica models in a macro model").

\begin{lstlisting}[language=XML]
<modelTemplate id="Template">
 <!-- insert here any unitDynamicModel, connect, initConnect... -->
\end{lstlisting}

The template is instantiated as:
\begin{lstlisting}[language=XML,numbers=none]
<modelTemplateExpansion id="TemplateModel" templateId="Template" parFile="MyPar.par" parId="6">
\end{lstlisting}

\subsubsection{Write connections}

The connections between the dynamics models are provided with the keyword ``connect'', and the connections between the initialization models are provided with the keyword ``initConnect''.
\begin{lstlisting}[language=XML]
<connect id1="id1" var1="var1" id2="id2" var2="var1"/>
<initConnect id1="id1" var1="var1" id2="id2" var2="var1"/>
\end{lstlisting}

Here are a few rules to follow to write models connections:
\begin{itemize}
\item When connecting to the AC network (C++ model), the id to use is ``NETWORK'';
\item For connections between precompiled models, id1 and id2 refer to the models id and var1 and var2 are simply the variables name;
\item For connections between unit Modelica models in a macro model, id1 and id2 refer to the unit models id and var1 and var2 are simply the variables name;
\item For connections between macro Modelica models, id1 and id2 refer to the macro models id and var1 and var2 should be built as:

\verb|unitModelId_VariableNameInModel|;
\end{itemize}

\subsubsection{Associate a dynamic model to a static component}

When an iidm file is used, a correspondence between the component in the iidm file and its dynamic equivalent in the dyd file is made thanks to the item ``staticId''.
\begin{lstlisting}[language=XML, morekeywords={staticId}]
<modelicaModel id="MyModel" staticId="MyModelIIDMId">
  ...
  <staticRef var="DynVarName" staticVar="StaticVarName"/>
</modelicaModel>
\end{lstlisting}

Static references may be defined in order to describe which dynamic variables may be used to update the iidm output file. Static references are often defined for active and reactive power. Here is an example:
\begin{lstlisting}[language=XML, morekeywords={staticRef}]
<modelicaModel id="MyGenerator" staticId="MyGeneratorIIDMId">
  ...
  <staticRef var="P_value" staticVar="p"/>
  <staticRef var="Q_value" staticVar="q"/>
  <staticRef var="state" staticVar="state"/>
</modelicaModel>
\end{lstlisting}

If no static references are done, the simulation will proceed but \Dynawo will not be able to output an iidm file.

\subsubsection{Define sets of connections}

The connection between two different dynamic models in the dyd file often needs more than one ``connect'' statement. For example,  in order to connect the reference frequency model to a generator model we need to connect three variables: omega, omegaRef, running. In order not to write the three connections for each generator model of the network, we can define a macro connection in the dyd file:
\begin{lstlisting}[language=XML, morekeywords={macroConnector}]
<macroConnector id="M1S_OMEGAREF_CONNECTOR">
  <connect var1="omega_grp_@INDEX@" var2="M1S_omega"/>
  <connect var1="running_grp_@INDEX@" var2="M1S_running"/>
  <connect var1="omegaRef_grp_@INDEX@" var2="M1S_omegaRef"/>
</macroConnector>
\end{lstlisting}

And then we can use this macro connection as many times as needed with the keyword ``macroConnect'':
\begin{lstlisting}[language=XML, morekeywords={macroConnect}]
<macroConnect connector="M1S_OMEGAREF_CONNECTOR" id1="MODEL_OMEGA_REF" index1="0" id2="Generator0"/>
<macroConnect connector="M1S_OMEGAREF_CONNECTOR" id1="MODEL_OMEGA_REF" index1="1" id2="Generator1"/>
<macroConnect connector="M1S_OMEGAREF_CONNECTOR" id1="MODEL_OMEGA_REF" index1="2" id2="Generator2"/>
\end{lstlisting}

A macro connection can also contain an ``initConnect'' statement.

\subsubsection{Define sets of static references}

For each dynamic model, we often need more than one ``staticRef'' statement to describe the link between the dynamic model and the static equivalent. For example, for the generator, we need to define three static references: active power, reactive power and connection state. In order not to write the three static references for each generator model of the network, we can define a macro static reference in the dyd file:
\begin{lstlisting}[language=XML, morekeywords={macroStaticReference}]
<macroStaticReference id="GEN">
  <staticRef var="P_value" staticVar="p"/>
  <staticRef var="Q_value" staticVar="q"/>
  <staticRef var="state" staticVar="state"/>
</macroStaticReference>
\end{lstlisting}

And then we can use this macro static reference as many times as needed with the keyword ``macroStaticRef'':
\begin{lstlisting}[language=XML, morekeywords={macroStaticRef}]
<modelicaModel id="MyGenerator" staticId="MyGeneratorIIDMId">
  ...
  <macroStaticRef id="GEN"/>
</modelicaModel>
\end{lstlisting}

\subsection{par file}

\subsubsection{Set a reference to a value stored in the iidm file or a given par file}
\label{sec:Set a reference to a value stored in the iidm file}

If the parameter's value is stored in the iidm file, a reference to this value can be added in the par file as in the example below:
\begin{lstlisting}[language=XML, morekeywords={reference}]
<set>
  <par type="ParType" name="ParName" value="ParValue"/>
  ...
  <reference type="RefType" name="RefName" origData="IIDM" origName="NameIIDM" componentId="Model_id_in_iidm_File"/>
</set>
\end{lstlisting}

When no componentId is given, it is assumed that the data is linked with the static component which id is given by the staticId defined in the dyd file.  \\

To use the value from another parameter, a parameter reference can be used as shown in the example below:

\begin{lstlisting}[language=XML, morekeywords={reference}]
<set>
  <par type="ParType" name="ParName" value="ParValue"/>
  ...
  <reference type="RefType" name="RefName1" origData="PAR" origName="NamePAR1" parId="ParID" parFile="parfile.par" />
  <reference type="RefType" name="RefName2" origData="PAR" origName="NamePAR2" parId="ParID" />
</set>
\end{lstlisting}

When no parFile is given, it is assumed that the referenced value is in the current par file. If neither the parFile nor the parId are provided, it is assumed that the referenced value is in the current par set of the current par file.

\subsubsection{Enter a table of parameter}

There is a special way of writing tables of parameters in the par file. To do so use a ``parTable'' item as in the example bellow.
\begin{lstlisting}[language=XML, morekeywords={parTable}]
<set>
  <parTable type="DOUBLE" name="MyTable">
    <par row="1" column="1" value="0.1"/>
    <par row="1" column="2" value="0.5"/>
    <par row="2" column="1" value="1.0"/>
    <par row="2" column="2" value="0"/>
  </parTable>
  ...
</set>
\end{lstlisting}

\subsection{crv file}

\subsubsection{Add a new curve to the curve file}

To add a new curve to the crv file, the following line should be added in the crv file:
\begin{lstlisting}[language=XML,numbers=none]
<curve model="ModelId" variable="var"/>
\end{lstlisting}

Here are a few rules to follow to write models variables names:
\begin{itemize}
\item For precompiled models, ModelId refers to the model id and var is simply the variable name;
\item For Modelica models, ModelId refers to the macro model id and var should be built as:

\verb|unitModelId_VariableNameInModel|;
\end{itemize}

\section{Basic errors in input files}

While trying to create its own input files, the user might encounter some error messages. This section provides basic explanations for the most common error messages related to the input files. \\

These error messages can be found in the dynawo.log file in the outputs directory specified in the jobs file, usually named ``outputs''.

\subsection{dyd file}

\subsubsection{Missing connection}

To be able to compile a Modelica model, \Dynawo needs it to be square, i.e. to have equal numbers of equations and variables. If it is not the case, \Dynawo should return the following message in dynawo.log: ``missing connection for one/several external variable(s)'' and provide the corresponding variables when in DEBUG mode. Typically, this situation can happen if one forgot to set a connect within a Modelica model in the .dyd file. \\

For example, if the user forgets to set the connection of Generator\_omegaRefPu, he might get the following error message:

\lstinputlisting[frame = lines, framesep = 2em]{../resources/exampleErrors/dynawoMissingConnection.log}

\subsubsection{Invalid connection due to connector's type}

Connected variables should share the same type (basically  Continuous, Discrete, Boolean or Integer). For simplification purposes and in order to identify easily which are the interface variables of the model, the current \Dynawo Modelica library offers to use specific connectors: ImPin whose attribute named value is a Real, ZPin whose attribute named value is a discrete Real, BPin whose attribute named value is a Boolean and ACPower whose attributes are V a complex voltage and i a complex current. \\

For example, if we connect an ImPin connector (let's say SP\_setPoint) to a BPin connector (Generator\_running), we will get the following error message:

\lstinputlisting[frame = lines, framesep = 2em, numbers=none]{../resources/exampleErrors/dynawoWrongConnectType.log}

\subsubsection{Invalid connection due to inconsistency}

The connect statements in the dyd file should link two connectors or two variables, but a connection between a connector and a variable is forbidden. \\

For example, if we connect the generator machine speed Generator\_omegaRefPu to a set point thanks to the variable SP\_setPoint\_value instead of using the connector SP\_setPoint, we will get the following error message:

\lstinputlisting[frame = lines, framesep = 2em, numbers=none]{../resources/exampleErrors/dynawoWrongConnect.log}

Here Generator\_omegaRefPu is an ImPin while SP\_setPoint\_value is a Real. The connection is impossible.

\subsection{par file}

\subsubsection{Parameter not found}

The user should make sure that every parameter of every model is set either via a par file or directly in the model. If a parameter's value is not defined, \Dynawo should return the following message: ``parameter $X$ not found in set $Y$''. \\

For example, if you forget to give a value for the parameter ``alpha'' of the load model, you will get the following message:
\lstinputlisting[frame = lines, framesep = 2em, numbers=none]{../resources/exampleErrors/dynawoParameterNotFound.log}

As the parameter ``alpha'' is not given a default value in the Modelica model Dynawo.Electrical.Loads.LoadAlphaBeta, it needs to be present in the parameters set of the par file.

\subsubsection{Wrong type of parameter}

Parameter's type declaration in the par file should match the parameter type in the corresponding model. \\

For example, if you declare the generator parameter $UPhase_0$ as an INT in the par file instead of a DOUBLE, you will get the following message:
\vspace{0.6cm} % vspace only for DynawoInputFiles standalone doc
\lstinputlisting[frame = lines, framesep = 2em, numbers=none]{../resources/exampleErrors/dynawoBadType.log}

$UPhase_0$ is defined as Real in the generator Modelica model and should be declared as a DOUBLE in the par file.

\subsection{crv file}

\subsubsection{Wrong variable name in crv file}

Mistakes in variables names in the crv file won't trigger any error message, but simply won't be taken into account in the generation of the output curves.csv. If it happens that you can't find the variable that was supposed to figure in curves.csv, check that it is written correctly.

\end{document}
