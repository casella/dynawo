diff --git a/Makefile.in b/Makefile.in
index 59a8b01feb..9e00f6e460 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -175,7 +175,7 @@ install: install-dirs
 	# License
 	cp -p OMCompiler/COPYING ${INSTALL_DOCDIR}/omc/
 	# Documents
-	test ! -e "doc" || cp -p doc/*.pdf ${INSTALL_DOCDIR}/omc/
+	test -e "doc" || cp -p doc/*.pdf ${INSTALL_DOCDIR}/omc/
 	cp -p "@OMBUILDDIR@"/share/doc/omc/testmodels/* ${INSTALL_DOCDIR}/omc/testmodels/
 	# man pages
 	# cp -p "@OMBUILDDIR@"/share/man/man1/*.gz ${INSTALL_MANDIR}/man1/
diff --git a/OMCompiler/Compiler/BackEnd/XMLCreateDynawo.mo b/OMCompiler/Compiler/BackEnd/XMLCreateDynawo.mo
new file mode 100644
index 0000000000..35fbdbe917
--- /dev/null
+++ b/OMCompiler/Compiler/BackEnd/XMLCreateDynawo.mo
@@ -0,0 +1,2236 @@
+/*
+* Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
+* See AUTHORS.txt
+* All rights reserved.
+* This Source Code Form is subject to the terms of the Mozilla Public
+* License, v. 2.0. If a copy of the MPL was not distributed with this
+* file, you can obtain one at http://mozilla.org/MPL/2.0/.
+* SPDX-License-Identifier: MPL-2.0
+*
+* This file is part of Dynawo, an hybrid C++/Modelica open source time domain simulation tool for power systems.
+*/
+
+ /****************************************************************************************************
+ * This file is part of OpenModelica.
+ *
+ *  XMLCreateDynawo permits the dumping of DAE as XML file for Dynawo software
+ *
+ ****************************************************************************************************
+ */
+
+encapsulated package XMLCreateDynawo
+" file:        XMLCreateDynawo.mo
+  package:     XMLCreateDynawo
+  description: Dumping of DAE as XML for Dynawo software
+
+  Author : Alain DUTOYA - InckA - Juin 2014
+  "
+
+//... public imports
+//--------------------------------------------------
+public import Absyn;
+public import BackendDAE;
+public import DAE;
+public import Values;
+public import SCode;
+
+//... protected imports
+//--------------------------------------------------
+protected
+import Algorithm;
+import Array;
+import BackendDAETransform;
+import BackendDAEUtil;
+import BackendDump;
+import BackendEquation;
+import BackendDAEEXT;
+import BackendVarTransform;
+import BackendVariable;
+import BaseHashTable;
+import CheckModel;
+import ClassInf;
+import ComponentReference;
+import DAEUtil;
+import DAEDump;
+import Debug;
+import Differentiate;
+import ElementSource;
+import Expression;
+import ExpressionDump;
+import ExpressionSolve;
+import ExpressionSimplify;
+import Error;
+import Flags;
+import HashTableExpToIndex;
+import HpcOmTaskGraph;
+import List;
+import Matching;
+import Print;
+import MetaModelica.Dangerous;
+import RewriteRules;
+import Sorting;
+import SynchronousFeatures;
+import Types;
+import Util;
+import ValuesUtil;
+
+//... Parameters
+//--------------------------------------------------
+
+  // General
+  //==========
+  protected constant String HEADER  = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
+
+  protected constant String RTE_OPEN  = "model";
+  protected constant String RTE_CLOSE = "model";
+
+  protected constant String RTE_MODELNAME = "name";
+
+  // VARIABLE
+  //==========
+  protected constant String RTE_VARIABLES_LIST       = "elements";
+  protected constant String RTE_DESIGNATION_VARIABLE = "terminal";
+  protected constant String RTE_STRUCT   = "struct";
+  protected constant String RTE_SUBNODES = "subnodes";
+
+  protected constant String RTE_STRUCTURE = "className";
+  protected constant String VAR_PATH = "path";
+
+  //This is the name that identifies the Variables' block. It's also used to compose the other
+  //Variables' names, such as KnownVariables, OrderedVariables, and so on.
+  protected constant String RTE_VARIABLES  = "variables";
+  protected constant String RTE_VARIABLES_ = "Variables";
+  //This is used all the time a variable is referenced.
+  protected constant String RTE_VARIABLE = "variable";
+
+  protected constant String ORDERED  = "var_dlow_";
+
+
+  protected constant String ELEMENT  = "element";
+  protected constant String ELEMENT_ = "Element";
+
+  protected constant String INDEX = "index";
+  protected constant String VALUE = "value";
+
+  protected constant String LIST_ = "List";
+
+  //Is the Dimension attribute of a list element.
+  protected constant String DIMENSION              = "dimension";
+  //Is the reference attribute for an element.
+  protected constant String ID                     = "id";
+  protected constant String ID_                    = "Id";
+  protected constant String CONDITION              = "Condition";
+
+  //This is the String attribute for the textual representation of the expressions.
+  protected constant String EXP_STRING               = "string";
+
+  protected constant String KNOWN    = "known";
+  protected constant String EXTERNAL = "external";
+  protected constant String ALIAS    = "alias";
+
+  protected constant String CLASSES  = "classes";
+  protected constant String CLASSES_ = "Classes";
+
+  protected constant String CLASS   = "class";
+  protected constant String CLASS_  = "Class";
+  protected constant String NAMES_  = "Names";
+
+  protected constant String VAR_COUNT    = "number";
+  protected constant String VAR_ID       = ID;
+  protected constant String VAR_NAME     = "name";
+  protected constant String VAR_INDEX    = "differentiatedIndex";
+
+  protected constant String STATE_SELECT_NEVER   = "Never";
+  protected constant String STATE_SELECT_AVOID   = "Avoid";
+  protected constant String STATE_SELECT_DEFAULT = "Default";
+  protected constant String STATE_SELECT_PREFER  = "Prefer";
+  protected constant String STATE_SELECT_ALWAYS  = "Always";
+
+  // CONNECTOR
+  //===========
+  protected constant String VAR_CONNECTOR = "connector";
+  protected constant String VAR_CONNECTOR_POTENTIAL    = "Potential";
+  protected constant String VAR_CONNECTOR_FLOW         = "Flow";
+  protected constant String VAR_CONNECTOR_STREAM       = "Stream";
+  protected constant String VAR_CONNECTOR_NOTCONNECTOR = "Non_Connector";
+
+  // VARIABILITY
+  //============
+  ///  TO CORRECT WITHIN THE OMC!!!  ///
+  // The variability is related to the
+  // possible values a variable can assume
+  // In this case also information for the
+  // variable are stored. For example it would be useful
+  // to print the information about state, dummyState, dummyDer separately.
+
+  //In addition to this there's a problem with the discrete states,
+  //since they aren't recognised as states.
+  protected constant String VAR_VARIABILITY = "kind";
+
+  protected constant String VARIABILITY_CONTINUOUS            = "continuous";
+  protected constant String VARIABILITY_CONTINUOUS_STATE      = "continuousState";
+  protected constant String VARIABILITY_CONTINUOUS_DUMMYDER   = "continuousDummyDer";
+  protected constant String VARIABILITY_CONTINUOUS_DUMMYSTATE = "continuousDummyState";
+  protected constant String VARIABILITY_DISCRETE              = "discrete";
+  protected constant String VARIABILITY_PARAMETER             = "parameter";
+  protected constant String VARIABILITY_CONSTANT              = "constant";
+  protected constant String VARIABILITY_EXTERNALOBJECT        = "externalObject";
+
+  // TYPE
+  //=====
+  protected constant String VAR_TYPE                    = "type";
+  protected constant String VARTYPE_INTEGER             = "Integer";
+  protected constant String VARTYPE_REAL                = "Real";
+  protected constant String VARTYPE_STRING              = "String";
+  protected constant String VARTYPE_BOOLEAN             = "Boolean";
+  protected constant String VARTYPE_ENUM                = "Enum";
+  protected constant String VARTYPE_ENUMERATION         = "enumeration";
+  protected constant String VARTYPE_EXTERNALOBJECT      = "ExternalObject";
+
+  // DIRECTION
+  //==========
+  protected constant String VAR_DIRECTION         = "direction";
+  protected constant String VARDIR_INPUT          = "input";
+  protected constant String VARDIR_OUTPUT         = "output";
+  protected constant String VARDIR_NONE           = "none";
+
+  // ATTRIBUT
+  //=========
+  protected constant String VAR_FIXED             = "fixed";
+  protected constant String VAR_COMMENT           = "comment";
+  protected constant String VAR_ATTRIBUTES_VALUES = "attributesValues";
+  protected constant String VAR_ATTR_QUANTITY     = "quantity";
+  protected constant String VAR_ATTR_UNIT         = "unit";
+  protected constant String VAR_ATTR_DISPLAY_UNIT = "displayUnit";
+  protected constant String VAR_ATTR_STATESELECT  = "stateSelect";
+  protected constant String VAR_ATTR_MINVALUE     = "minValue";
+  protected constant String VAR_ATTR_MAXVALUE     = "maxValue";
+  protected constant String VAR_ATTR_NOMINAL      = "nominal";
+  protected constant String VAR_ATTR_INITIALVALUE = "initialValue";
+  protected constant String VAR_ATTR_FIXED        = "fixed";
+
+  //Name of the element representing the subscript, for example the array's index.
+  protected constant String SUBSCRIPT               = "subscript";
+
+  //Additional info for variables.
+  protected constant String HASH_TB_CREFS_LIST          = "hashTb";
+  protected constant String HASH_TB_STRING_LIST_OLDVARS = "hashTbOldVars";
+
+  //All this constants below are used in the createDAE2Dynawo method.
+  protected constant String SIMPLE             = "simple";
+  protected constant String INITIAL            = "initial";
+  protected constant String ZERO_CROSSING      = "zeroCrossing";
+  protected constant String SAMPLES            = "Samples";
+
+  protected constant String RESIDUAL     = "residual";
+  protected constant String RESIDUAL_    = "Residual";
+
+  protected constant String FUNCTIONS               = "functions";
+  protected constant String FUNCTION                = "function";
+  protected constant String FUNCTION_NAME           = "name";
+  protected constant String NAME_BINDINGS           = "nameBindings";
+  protected constant String C_NAME                  = "cName";
+  protected constant String C_IMPLEMENTATIONS       = "cImplementations";
+  protected constant String MODELICA_IMPLEMENTATION = "ModelicaImplementation";
+
+
+  protected constant String MATH                   = "math";
+  protected constant String MathML                 = "MathML";
+  protected constant String MathMLApply            = "apply";
+  protected constant String MathMLWeb              = "http://www.w3.org/1998/Math/MathML";
+  protected constant String MathMLXmlns            = "xmlns";
+  protected constant String MathMLType             = "type";
+  protected constant String MathMLNumber           = "cn";
+  protected constant String MathMLVariable         = "ci";
+  protected constant String MathMLConstant         = "constant";
+  protected constant String MathMLInteger          = "integer";
+  protected constant String MathMLReal             = "real";
+  protected constant String MathMLVector           = "vector";
+  protected constant String MathMLMatrixrow        = "matrixrow";
+  protected constant String MathMLMatrix           = "matrix";
+  protected constant String MathMLTrue             = "true";
+  protected constant String MathMLFalse            = "false";
+  protected constant String MathMLAnd              = "and";
+  protected constant String MathMLOr               = "or";
+  protected constant String MathMLNot              = "not";
+  protected constant String MathMLEqual            = "eq";
+  protected constant String MathMLLessThan         = "lt";
+  protected constant String MathMLLessEqualThan    = "leq";
+  protected constant String MathMLGreaterThan      = "gt";
+  protected constant String MathMLGreaterEqualThan = "geq";
+  protected constant String MathMLEquivalent       = "equivalent";
+  protected constant String MathMLNotEqual         = "neq";
+  protected constant String MathMLPlus             = "plus";
+  protected constant String MathMLMinus            = "minus";
+  protected constant String MathMLTimes            = "times";
+  protected constant String MathMLDivide           = "divide";
+  protected constant String MathMLPower            = "power";
+  protected constant String MathMLTranspose        = "transpose";
+  protected constant String MathMLScalarproduct    = "scalarproduct";
+  protected constant String MathMLVectorproduct    = "vectorproduct";
+  protected constant String MathMLInterval         = "interval";
+  protected constant String MathMLSelector         = "selector";
+
+  protected constant String MathMLIfClause         = "piecewise";
+  protected constant String MathMLIfBranch         = "piece";
+  protected constant String MathMLElseBranch       = "otherwise";
+
+  protected constant String MathMLOperator         = "mo";
+  protected constant String MathMLArccos           = "arccos";
+  protected constant String MathMLArcsin           = "arcsin";
+  protected constant String MathMLArctan           = "arctan";
+  protected constant String MathMLLn               = "ln";
+  protected constant String MathMLLog              = "log";
+
+//---------------------------------------------------------------------------
+public function binopSymbol "
+function: binopSymbol
+  Return a string representation of the Operator
+  corresponding to the MathML encode. "
+  input DAE.Operator inOperator;
+  output String outString;
+algorithm
+  outString:=
+  match (inOperator)
+    local
+      DAE.Ident s;
+      DAE.Operator op;
+    case op
+      equation
+        s = binopSymbol2(op);
+      then
+        s;
+  end match;
+end binopSymbol;
+
+public function binopSymbol2 "
+Helper function to binopSymbol"
+  input DAE.Operator inOperator;
+  output String outString;
+algorithm
+  outString:=
+  match (inOperator)
+    local String error_msg;
+    case (DAE.ADD(ty = _)) then MathMLPlus;
+    case (DAE.SUB(ty = _)) then MathMLMinus;
+    case (DAE.MUL(ty = _)) then MathMLTimes;
+    case (DAE.DIV(ty = _)) then MathMLDivide;
+    case (DAE.POW(ty = _)) then MathMLPower;
+    case (DAE.ADD_ARR(ty = _)) then MathMLPlus;
+    case (DAE.SUB_ARR(ty = _)) then MathMLMinus;
+    case (DAE.MUL_ARRAY_SCALAR(ty = _)) then MathMLTimes;
+    case (DAE.MUL_SCALAR_PRODUCT(ty = _)) then MathMLScalarproduct;
+    case (DAE.MUL_MATRIX_PRODUCT(ty = _)) then MathMLVectorproduct;
+    case (DAE.DIV_ARRAY_SCALAR(ty = _)) then MathMLDivide;
+    else
+      equation
+        error_msg = "in XMLCreateDynawo.binopSymbol2 - Unknown operator: ";
+        error_msg = error_msg + ExpressionDump.debugBinopSymbol(inOperator);
+        Error.addMessage(Error.INTERNAL_ERROR, {error_msg});
+      then
+        fail();
+  end match;
+end binopSymbol2;
+
+public function dumpAbsynPathLst "
+This function prints a list of Absyn.Path using an XML representation.
+If the list of element is empty the methods doesn't print nothing,
+otherwise, depending on the value of the second input (the String content) prints:
+<Content>
+  ...//List of paths
+</Content>
+"
+  input list<Absyn.Path> absynPathLst;
+  input String Content;
+algorithm
+  _ := matchcontinue (absynPathLst,Content)
+    local
+      Integer len;
+    case ({},_)
+      then();
+    case (_,_)
+      equation
+        len = listLength(absynPathLst);
+        len >= 1 = false;
+      then ();
+    case (_,_)
+      equation
+        len = listLength(absynPathLst);
+        len >= 1 = true;
+        dumpStrOpenTag(Content);
+
+        //str =Absyn.pathStringNoQual(absynPathLst); Avoir Alain
+        dumpAbsynPathLst2(absynPathLst);
+
+        dumpStrCloseTag(Content);
+      then();
+  end matchcontinue;
+end dumpAbsynPathLst;
+
+protected function dumpAbsynPathLst2 "
+This is an helper function to the dunmAbsynPathList method.
+"
+  input list<Absyn.Path> absynPathLst;
+algorithm
+  _:= match (absynPathLst)
+        local
+          list<Absyn.Path> apLst;
+          Absyn.Path ap;
+          String str;
+      case {} then ();
+      case (ap :: apLst)
+      equation
+        str=AbsynUtil.pathStringNoQual(ap);
+        dumpStrTagContent(ELEMENT,str);
+        dumpAbsynPathLst2(apLst);
+      then();
+    end match;
+end dumpAbsynPathLst2;
+
+protected function dumpComment "
+Function for adding comments using the XML tag.
+"
+  input String inComment;
+algorithm
+  Print.printBuf("<!--");
+  Print.printBuf(Util.xmlEscape(inComment));
+  Print.printBuf("-->");
+end dumpComment;
+
+protected function getEqsList
+  input BackendDAE.EqSystem syst;
+  input list<BackendDAE.Equation> inEqns;
+  output list<BackendDAE.Equation> outEqns;
+protected
+  list<BackendDAE.Equation> eqnsl;
+algorithm
+  eqnsl := BackendEquation.equationList(BackendEquation.getEqnsFromEqSystem(syst));
+  outEqns := listAppend(inEqns,eqnsl);
+end getEqsList;
+
+public function dumpDirectionStr "
+This function dumps the varDirection of a variable:
+ it could be:
+ - input
+ - output
+"
+  input DAE.VarDirection inVarDirection;
+  output String outString;
+algorithm
+  outString:=
+  match (inVarDirection)
+    local String error_msg;
+    case DAE.INPUT()  then VARDIR_INPUT;
+    case DAE.OUTPUT() then VARDIR_OUTPUT;
+    case DAE.BIDIR()  then VARDIR_NONE;
+    else
+      equation
+        error_msg = "in XMLCreateDynawo.dumpDirectionStr - Unknown var direction";
+        Error.addMessage(Error.INTERNAL_ERROR, {error_msg});
+      then
+        fail();
+  end match;
+end dumpDirectionStr;
+
+public function dumpExp
+"This function prints a complete expression
+  as a MathML. The content is like:
+  <MathML>
+  <MATH xmlns=\"http://www.w3.org/1998/Math/MathML\">
+  DAE.Exp
+  </MATH>
+  </MathML>"
+  input DAE.Exp e;
+  //output String s;
+  input Boolean addMathMLCode;
+algorithm
+  _:=
+  matchcontinue (e,addMathMLCode)
+    local
+      DAE.Exp inExp;
+    case(inExp,true)
+      equation
+        dumpStrOpenTag(MathML);
+        dumpStrOpenTagAttr(MATH, MathMLXmlns, MathMLWeb);
+        dumpExp2(inExp);
+        dumpStrCloseTag(MATH);
+        dumpStrCloseTag(MathML);
+      then();
+    case(_,false)
+      then();
+    case(_,_) then();
+  end matchcontinue;
+end dumpExp;
+
+public function dumpExp2
+"Helper function to dumpExpression. It can also
+  be used if it's not necessary to print the headers
+  (MathML and MATH tags)."
+  input DAE.Exp inExp;
+algorithm
+  _:=
+  matchcontinue (inExp)
+    local
+      DAE.Ident s,sym,res,str;
+      DAE.Ident fs;
+      Integer x,ival;
+      Real rval;
+      DAE.ComponentRef c;
+      DAE.Type t,tp;
+      DAE.Exp e1,e2,e,start,stop,step,cr,dim,cond,tb,fb;
+      DAE.Operator op;
+      Absyn.Path fcn;
+      list<DAE.Exp> args,es;
+      list<list<DAE.Exp>> ebs;
+    case (DAE.ICONST(integer = x))
+      equation
+        dumpStrMathMLNumberAttr(intString(x),MathMLType,MathMLInteger);
+      then ();
+    case (DAE.RCONST(real = rval))
+      equation
+        dumpStrMathMLNumberAttr(realString(rval),MathMLType,MathMLReal);
+      then ();
+    case (DAE.SCONST(string = s))
+      equation
+        dumpStrMathMLNumberAttr(Util.xmlEscape(s),MathMLType,MathMLConstant);
+      then ();
+    case (DAE.BCONST(bool = false))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLFalse);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.BCONST(bool = true))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLTrue);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CREF(componentRef = c,ty = t))
+      equation
+        s = ComponentReference.printComponentRefStr(c);
+        dumpStrMathMLVariable(s);
+      then ();
+    case (e as DAE.BINARY(e1,op,e2))
+      equation
+        sym = binopSymbol(op);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(sym);
+        dumpExp2(e1);
+        dumpExp2(e2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+     case ((e as DAE.UNARY(op,e1)))
+      equation
+        sym = unaryopSymbol(op);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(sym);
+        dumpExp2(e1);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+   case ((e as DAE.LBINARY(e1,op,e2)))
+      equation
+        sym = lbinopSymbol(op);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(sym);
+        dumpExp2(e1);
+        dumpExp2(e2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+   case ((e as DAE.LUNARY(op,e1)))
+      equation
+        sym = lunaryopSymbol(op);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(sym);
+        dumpExp2(e1);
+        dumpStrCloseTag(MathMLApply);
+      then();
+   case ((e as DAE.RELATION(exp1=e1,operator=op,exp2=e2)))
+      equation
+        sym = relopSymbol(op);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(sym);
+        dumpExp2(e1);
+        dumpExp2(e2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case ((e as DAE.IFEXP(cond,tb,fb)))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrOpenTag(MathMLIfClause);
+        dumpStrOpenTag(MathMLIfBranch);
+        dumpExp2(tb);
+        dumpExp2(cond);
+        dumpStrCloseTag(MathMLIfBranch);
+        dumpStrOpenTag(MathMLElseBranch);
+        dumpExp2(fb);
+        dumpStrCloseTag(MathMLElseBranch);
+        dumpStrCloseTag(MathMLIfClause);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CALL(path = Absyn.IDENT(name = "der"),expLst = args))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag("diff");
+        dumpList(args,dumpExp2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CALL(path = Absyn.IDENT(name = "acos"),expLst = args))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLArccos);
+        dumpList(args,dumpExp2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CALL(path = Absyn.IDENT(name = "asin"),expLst = args))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLArcsin);
+        dumpList(args,dumpExp2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CALL(path = Absyn.IDENT(name = "atan"),expLst = args))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLArctan);
+        dumpList(args,dumpExp2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CALL(path = Absyn.IDENT(name = "atan2"),expLst = args))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf("atan2");
+        dumpStrCloseTag(MathMLOperator);
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf("(");
+        dumpStrCloseTag(MathMLOperator);
+        dumpList(args,dumpExp2);
+        dumpComment("atan2 is not a MathML element it could be possible to use arg in future");
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf(")");
+        dumpStrCloseTag(MathMLOperator);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CALL(path = Absyn.IDENT(name = "log"),expLst = args))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLLn);
+        dumpList(args,dumpExp2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CALL(path = Absyn.IDENT(name = "log10"),expLst = args))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLLog);
+        dumpList(args,dumpExp2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+/*
+    case (DAE.CALL(path = Absyn.IDENT(name = "pre"),expLst = args))
+      equation
+        fs = Absyn.pathStringNoQual(fcn);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag("selector");          ----THIS IS FOR ALGORITHM----
+        dumpList(args,dumpExp2);
+        dumpStrMathMLVariable("t-1");
+        dumpStrCloseTag("apMathMLApply;
+      then ();
+*/
+    case (DAE.CALL(path = fcn,expLst = args))
+      equation
+        // Add the ref to path
+        fs = AbsynUtil.pathStringNoQual(fcn);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(fs);
+        dumpList(args,dumpExp2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.ARRAY(array = es,ty=tp))//Array are dumped as vector
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLTranspose);
+        dumpStrOpenTag(MathMLVector);
+        dumpList(es,dumpExp3);
+        dumpStrCloseTag(MathMLVector);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.TUPLE(PR = es))//Tuple are dumped as vector
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLTranspose);
+        dumpStrOpenTag(MathMLVector);
+        dumpList(es,dumpExp2);
+        dumpStrCloseTag(MathMLVector);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.MATRIX(matrix = ebs,ty=tp))
+      equation
+        dumpStrOpenTag(MathMLMatrix);
+        dumpStrOpenTag(MathMLMatrixrow);
+        dumpListSeparator(ebs, dumpRow, stringAppendList({"\n</",MathMLMatrixrow,">\n<",MathMLMatrixrow,">"}));
+        dumpStrCloseTag(MathMLMatrixrow);
+        dumpStrCloseTag(MathMLMatrix);
+      then ();
+    case (e as DAE.RANGE(_,start,NONE(),stop))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrOpenTag(MathMLInterval);
+        dumpExp2(start);
+        dumpExp2(stop);
+        dumpStrCloseTag(MathMLInterval);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case ((e as DAE.RANGE(_,start,SOME(step),stop)))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf("{");
+        dumpStrCloseTag(MathMLOperator);
+        dumpExp2(start);
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf(":");
+        dumpStrCloseTag(MathMLOperator);
+        dumpExp2(step);
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf(":");
+        dumpStrCloseTag(MathMLOperator);
+        dumpExp2(stop);
+        dumpComment("Interval range specification is not supported by MathML standard");
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf("}");
+        dumpStrCloseTag(MathMLOperator);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CAST(ty = DAE.T_REAL(varLst = _),exp = DAE.ICONST(integer = ival)))
+      equation
+        false = Config.modelicaOutput();
+        rval = intReal(ival);
+        res = realString(rval);
+        dumpStrMathMLNumberAttr(res,MathMLType,MathMLReal);
+      then ();
+    case (DAE.CAST(ty = DAE.T_REAL(varLst = _),exp = DAE.UNARY(operator = DAE.UMINUS(ty = _),exp = DAE.ICONST(integer = ival))))
+      equation
+        false = Config.modelicaOutput();
+        rval = intReal(ival);
+        res = realString(rval);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLMinus);
+        dumpStrMathMLNumberAttr(res,MathMLType,MathMLReal);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CAST(ty = DAE.T_REAL(varLst = _),exp = e))
+      equation
+        false = Config.modelicaOutput();
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLReal);
+        dumpExp2(e);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.CAST(ty = DAE.T_REAL(varLst = _),exp = e))
+      equation
+        true = Config.modelicaOutput();
+        dumpExp2(e);
+      then ();
+    case (DAE.CAST(ty = tp,exp = e))
+      equation
+        str = Types.unparseType(tp);
+        dumpStrOpenTag(MathMLApply);
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf("(");
+        dumpStrCloseTag(MathMLOperator);
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf("CAST as ");Print.printBuf(str);
+        dumpStrCloseTag(MathMLOperator);
+        dumpExp2(e);
+        dumpComment("CAST operator is not supported by MathML standard.");
+        dumpStrOpenTag(MathMLOperator);
+        Print.printBuf(")");
+        dumpStrCloseTag(MathMLOperator);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (e as DAE.ASUB(exp = e1,sub = {e2}))
+      equation
+        dumpStrOpenTag(MathMLApply);
+        dumpStrVoidTag(MathMLSelector);
+        dumpExp2(e1);
+        dumpExp2(e2);
+        dumpStrCloseTag(MathMLApply);
+      then ();
+    case (DAE.ENUM_LITERAL(name = fcn))
+      equation
+        dumpStrMathMLVariable(AbsynUtil.pathStringNoQual(fcn));
+      then ();
+    case (DAE.SIZE(exp = cr,sz = SOME(dim)))
+      equation
+        // NOT PART OF THE MODELICA LANGUAGE
+      then ();
+    case (DAE.SIZE(exp = cr,sz = NONE()))
+      equation
+        // NOT PART OF THE MODELICA LANGUAGE
+      then ();
+    case (DAE.REDUCTION(expr = _))
+      equation
+        // NOT PART OF THE MODELICA LANGUAGE
+      then  ();
+      // MetaModelica list
+    case (DAE.LIST(valList=es))
+      equation
+        // NOT PART OF THE MODELICA LANGUAGE
+      then ();
+        // MetaModelica list cons
+    case (DAE.CONS(car=e1,cdr=e2))
+      equation
+        // NOT PART OF THE MODELICA LANGUAGE
+      then ();
+    case (_)
+      equation
+        dumpComment("UNKNOWN EXPRESSION");
+      then ();
+  end matchcontinue;
+end dumpExp2;
+
+public function dumpExp3
+"This function is an auxiliary function for dumpExp2 function.
+"
+  input DAE.Exp e;
+  //output String s;
+algorithm
+  dumpStrOpenTag(MathML);
+  dumpStrOpenTagAttr(MATH, MathMLXmlns, MathMLWeb);
+  dumpExp2(e);
+  dumpStrCloseTag(MATH);
+  dumpStrCloseTag(MathML);
+end dumpExp3;
+
+public function dumpLibs
+  input list<String> libs;
+algorithm
+  _:=
+  matchcontinue (libs)
+    local
+      String s;
+      list<String> remaining;
+  case ({}) then ();
+  case (s :: remaining)
+    equation
+      Print.printBuf(s);
+    then();
+  end matchcontinue;
+end dumpLibs;
+
+public function dumpKind "
+This function returns a string containing
+the kind of a variable, that could be:
+ - Variable
+ - State
+ - Dummy_der
+ - Dummy_state
+ - Discrete
+ - Parameter
+ - Constant
+ - ExternalObject:PathRef
+"
+  input BackendDAE.VarKind inVarKind;
+  output String outString;
+algorithm
+  outString :=
+  match (inVarKind)
+    local Absyn.Path path; String error_msg;
+    case BackendDAE.VARIABLE()     then (VARIABILITY_CONTINUOUS);
+    case BackendDAE.STATE(index=_)        then (VARIABILITY_CONTINUOUS_STATE);
+    case BackendDAE.DUMMY_DER()    then (VARIABILITY_CONTINUOUS_DUMMYDER);
+    case BackendDAE.DUMMY_STATE()  then (VARIABILITY_CONTINUOUS_DUMMYSTATE);
+    case BackendDAE.DISCRETE()     then (VARIABILITY_DISCRETE);
+    case BackendDAE.PARAM()        then (VARIABILITY_PARAMETER);
+    case BackendDAE.CONST()        then (VARIABILITY_CONSTANT);
+    case BackendDAE.EXTOBJ(path)
+      then (stringAppend(VARIABILITY_EXTERNALOBJECT,stringAppend(":",AbsynUtil.pathStringNoQual(path))));
+    else
+      equation
+        error_msg = "in XMLCreateDynawo.dumpKind - Unknown kind";
+        Error.addMessage(Error.INTERNAL_ERROR, {error_msg});
+      then
+        fail();
+  end match;
+end dumpKind;
+
+
+public function dumpList
+"Print a list of values given a print function."
+  input list<Type_a> inTypeALst;
+  input FuncTypeType_aTo inFuncTypeTypeATo;
+  replaceable type Type_a subtypeof Any;
+  partial function FuncTypeType_aTo
+    input Type_a inTypeA;
+  end FuncTypeType_aTo;
+algorithm
+  _:=
+  matchcontinue (inTypeALst,inFuncTypeTypeATo)
+    local
+      Type_a h;
+      FuncTypeType_aTo r;
+      list<Type_a> t;
+    case ({},_)  then ();
+    case ({h},r) equation  r(h);  then  ();
+    case ((h :: t),r)
+      equation
+        r(h);
+        dumpList(t, r);
+      then ();
+  end matchcontinue;
+end dumpList;
+
+
+public function dumpListSeparator
+"Print a list of values given a print
+  function and a separator string."
+  input list<Type_a> inTypeALst;
+  input FuncTypeType_aTo inFuncTypeTypeATo;
+  input String inString;
+  replaceable type Type_a subtypeof Any;
+  partial function FuncTypeType_aTo
+    input Type_a inTypeA;
+  end FuncTypeType_aTo;
+algorithm
+  _:=
+  matchcontinue (inTypeALst,inFuncTypeTypeATo,inString)
+    local
+      Type_a h;
+      FuncTypeType_aTo r;
+      list<Type_a> t;
+      DAE.Ident sep;
+    case ({},_,_)  then ();
+    case ({h},r,_) equation  r(h);  then  ();
+    case ((h :: t),r,sep)
+      equation
+        r(h);
+        Print.printBuf(sep);
+        dumpListSeparator(t, r, sep);
+      then ();
+  end matchcontinue;
+end dumpListSeparator;
+
+
+public function dumpLstExp "
+This function dumps an array of Equation using an XML format.
+It takes as input the list and a String
+for the content.
+If the list is empty then is doesn't print anything, otherwise
+the output is like:
+<ContentList Dimesion=...>
+  <Content>
+    ...
+  </Content>
+  ...
+</ContentList>
+ "
+  input list<DAE.Exp> inLstExp;
+  input String inContent;
+  input Boolean addMathMLCode;
+algorithm
+  _:=
+  matchcontinue (inLstExp,inContent,addMathMLCode)
+    local
+      Integer len;
+      String Lst;
+    case ({},_,_) then ();
+    case (_,_,_)
+      equation
+        len = listLength(inLstExp);
+        len >= 1 = false;
+      then();
+    else
+      equation
+        len = listLength(inLstExp);
+        len >= 1 = true;
+        Lst = stringAppend(inContent,LIST_);
+        dumpStrOpenTagAttr(Lst, DIMENSION, intString(len));
+        dumpLstExp2(inLstExp,inContent,addMathMLCode);
+        dumpStrCloseTag(Lst);
+      then ();
+  end matchcontinue;
+end dumpLstExp;
+
+
+protected function dumpLstExp2 "
+This is the help function of the dumpLstExp function.
+It takes the list of DAE.Exp and print out the
+list in a XML format.
+The output, if the list is not empty is something like this:
+<ARRAY_EQUATION String=ExpressionDump.printExpStr(firstEquation)>
+  <MathML>
+    <MATH>
+      ...
+    </MATH>
+  </MathML>
+</ARRAY_EQUATION>
+...
+<ARRAY_EQUATION String=ExpressionDump.printExpStr(lastEquation)>
+  <MathML>
+    <MATH>
+      ...
+    </MATH>
+  </MathML>
+</ARRAY_EQUATION>
+"
+  input list<DAE.Exp> inLstExp;
+  input String Content;
+  input Boolean addMathMLCode;
+algorithm
+  _:=
+  match (inLstExp,Content,addMathMLCode)
+    local
+      String s;
+      DAE.Exp e;
+      list<DAE.Exp> es;
+    case ({},_,_) then ();
+    case ((e :: es),_,_)
+      equation
+        s = printExpStr(e);
+        dumpStrOpenTagAttr(Content, EXP_STRING, s);
+        dumpExp(e,addMathMLCode);
+        dumpStrCloseTag(Content);
+        dumpLstExp2(es,Content,addMathMLCode);
+      then ();
+  end match;
+end dumpLstExp2;
+
+protected function printExpStr
+  input DAE.Exp e;
+  output String s;
+algorithm
+  s := Util.xmlEscape(ExpressionDump.printExpStr(e));
+end printExpStr;
+
+public function dumpLstInt "
+function dumpLsTStr dumps a list
+of Integer as a list of XML Element.
+The method takes the String list and
+the element name as inputs.
+The output is:
+
+<ElementName>FirstIntegerOfList</ElementName>
+..
+<ElementName>LastIntegerOfList</ElementName>
+
+"
+  input list<Integer> inLstStr;
+  input String inElementName;
+algorithm
+  _:=
+  matchcontinue(inLstStr,inElementName)
+      local
+        Integer h;
+        list<Integer> t;
+    case ({},_) then ();
+    case ({h},"") then ();
+    case ({h},_)
+      equation
+        dumpStrTagContent(inElementName,intString(h));
+    then  ();
+    case ((h :: t),_)
+      equation
+        dumpStrTagContent(inElementName,intString(h));
+        dumpLstInt(t,inElementName);
+    then();
+  end matchcontinue;
+end dumpLstInt;
+
+
+public function dumpLstIntAttr "
+This function, if the list is not empty, prints
+the XML delimiters tag of the list.
+"
+  input list<Integer> lst;
+  input String inContent;
+  input String inElementContent;
+algorithm
+  _:= matchcontinue (lst,inContent,inElementContent)
+  local
+    list<Integer> l;
+    String inLst,inEl;
+    case ({},_,_) then ();
+    case (l,inLst,inEl)
+      equation
+        dumpStrOpenTag(inLst);
+        dumpLstInt(l,inEl);
+        dumpStrCloseTag(inLst);
+      then();
+  end matchcontinue;
+end dumpLstIntAttr;
+
+public function dumpLstStr "
+Function dumpLsTStr dumps a list
+of String as a list of XML Element.
+The method takes the String list as
+input. The output is:
+<ELEMENT>FirstStringOfList</ELEMENT>
+..
+<ELEMENT>LastStringOfList</ELEMENT>
+"
+  input list<String> inLstStr;
+algorithm
+  _:=
+  matchcontinue(inLstStr)
+      local
+        String h;
+        list<String> t;
+    case {} then ();
+    case {h}
+      equation
+        dumpStrTagContent(ELEMENT,h);
+    then  ();
+    case (h :: t)
+      equation
+        dumpStrTagContent(ELEMENT,h);
+        dumpLstStr(t);
+    then();
+  end matchcontinue;
+end dumpLstStr;
+
+public function dumpOptExp "
+This function print to a new line the content of
+a Optional<DAE.Exp> in a XML element like:
+<Content =ExpressionDump.printExpStr(e)/>. It also print
+the content of the expression as MathML like:
+<MathML><MATH xmlns=...>DAE.Exp</MATH></MathML>.
+See dumpExp function for more details.
+"
+  input Option<DAE.Exp> inExpExpOption;
+  input String Content;
+  input Boolean addMathMLCode;
+algorithm
+  _:=
+  match (inExpExpOption,Content,addMathMLCode)
+    local
+      DAE.Exp e;
+    case (NONE(),_,_) then ();
+    case (SOME(e),_,_)
+      equation
+        dumpStrOpenTagAttr(Content,EXP_STRING,printExpStr(e));
+        dumpExp(e,addMathMLCode);
+        dumpStrCloseTag(Content);
+      then ();
+  end match;
+end dumpOptExp;
+
+public function dumpOptInteger "
+This function print to a new line the content of
+a Optional<Integer> in a XML element like:
+<Content index = intString(e)/>.
+"
+  input Option<Integer> inOption;
+  input String Content;
+  input Boolean addMathMLCode;
+algorithm
+  _:=
+  match (inOption,Content,addMathMLCode)
+    local
+      Integer i;
+
+    case (NONE(),_,_) then ();
+
+    case (SOME(i),_,_)
+      equation
+        dumpStrOpenTagAttr(Content,INDEX,intString(i));
+        dumpStrCloseTag(Content);
+      then ();
+
+  end match;
+end dumpOptInteger;
+
+public function dumpOptionDAEStateSelect "
+This function is used to print in a new line
+an element corresponding to the StateSelection
+choice of a variable. Depending from the String
+input, that defines the element's name, the
+element is something like:
+<Content=StateSelection/>,
+"
+  input Option<DAE.StateSelect> ss;
+  input String Content;
+algorithm
+  _ :=
+  match (ss,Content)
+    case (NONE(),_)
+      equation
+        Print.printBuf("");
+      then ();
+    case (SOME(DAE.NEVER()),_)
+      equation dumpStrTagContent(Content, STATE_SELECT_NEVER);   then ();
+    case (SOME(DAE.AVOID()),_)
+      equation dumpStrTagContent(Content, STATE_SELECT_AVOID);   then ();
+    case (SOME(DAE.DEFAULT()),_)
+      equation dumpStrTagContent(Content, STATE_SELECT_DEFAULT); then ();
+    case (SOME(DAE.PREFER()),_)
+      equation dumpStrTagContent(Content, STATE_SELECT_PREFER);  then ();
+    case (SOME(DAE.ALWAYS()),_)
+      equation dumpStrTagContent(Content, STATE_SELECT_ALWAYS);  then ();
+  end match;
+end dumpOptionDAEStateSelect;
+
+public function dumpOptValue "
+ This function print an Optional Values.Value variable
+as one attribute of a within a specific XML element.
+It takes the optional Values.Value and element name
+as input an prints on a new line a string to the
+standard output like:
+<Content = \"ExpressionDump.printExpStr(ValuesUtil.valueExp(Optional<Values.Value>)/>
+"
+  input Option<Values.Value> inValueValueOption;
+  input String Content;
+  input Boolean addMathMLCode;
+algorithm
+  _ :=
+  match (inValueValueOption,Content,addMathMLCode)
+    local
+      Values.Value v;
+      Boolean addMMLCode;
+    case (NONE(),_,_)  then ();
+    case (SOME(v),_,addMMLCode)
+      equation
+        dumpStrOpenTagAttr(Content,EXP_STRING,printExpStr(ValuesUtil.valueExp(v)));
+        dumpExp(ValuesUtil.valueExp(v),addMMLCode);
+        dumpStrCloseTag(Content);
+      then ();
+  end match;
+end dumpOptValue;
+
+public function dumpRow
+"Prints a list of expressions to a string."
+  input list<DAE.Exp> es_1;
+  annotation(__OpenModelica_EarlyInline=true);
+algorithm
+  dumpList(es_1, dumpExp2);
+end dumpRow;
+
+public function dumpStrMathMLNumber "
+This function prints a new MathML element
+containing a number, like:
+<cn> inNumber </cn>
+"
+  input String inNumber;
+algorithm
+  dumpStrOpenTag(MathMLNumber);
+  Print.printBuf(" ");Print.printBuf(inNumber);Print.printBuf(" ");
+  dumpStrCloseTag(MathMLNumber);
+end dumpStrMathMLNumber;
+
+public function dumpStrMathMLNumberAttr "
+This function prints a new MathML element
+containing a number and one of its attributes,
+like:
+<cn inAttribute=\"inAttributeValue\"> inNumber
+</cn>
+"
+  input String inNumber;
+  input String inAttribute;
+  input String inAttributeContent;
+algorithm
+  dumpStrOpenTagAttr(MathMLNumber, inAttribute, inAttributeContent);
+  Print.printBuf(" ");Print.printBuf(inNumber);Print.printBuf(" ");
+  dumpStrCloseTag(MathMLNumber);
+end dumpStrMathMLNumberAttr;
+
+public function dumpStrMathMLVariable"
+This function prints a new MathML element
+containing a variable (identifier), like:
+<ci> inVariable </ci>"
+  input String inVariable;
+algorithm
+  dumpStrOpenTag(MathMLVariable);
+  Print.printBuf(" ");Print.printBuf(inVariable);Print.printBuf(" ");
+  dumpStrCloseTag(MathMLVariable);
+end dumpStrMathMLVariable;
+
+public function dumpStrOpenTagAttr "
+  Function necessary to print the begin of a new
+  XML element containing an attribute. The XML
+  element's name, the name and the content of the
+  element's attribute are passed as String inputs.
+  The result is to print on a new line
+  a string like:
+  <Content Attribute=AttributeContent>
+  "
+  input String inContent;
+  input String Attribute;
+  input String AttributeContent;
+algorithm
+  _:=
+  matchcontinue (inContent,Attribute,AttributeContent)
+      local String inString,inAttribute,inAttributeContent;
+  case ("",_,_)  equation  Print.printBuf("");  then();
+  case (_,"",_)  equation  Print.printBuf("");  then();
+  case (_,_,"")  equation  Print.printBuf("");  then();
+  case (inString,"",_)  equation dumpStrOpenTag(inString);  then ();
+  case (inString,_,"")  equation dumpStrOpenTag(inString);  then ();
+  case (inString,inAttribute,inAttributeContent)
+    equation
+      Print.printBuf("\n<");Print.printBuf(inString);Print.printBuf(" ");Print.printBuf(Attribute);Print.printBuf("=\"");Print.printBuf(inAttributeContent);Print.printBuf("\">");
+    then();
+  end matchcontinue;
+end dumpStrOpenTagAttr;
+
+public function dumpStrTagAttrNoChild "
+  Function necessary to print a new
+  XML element containing an attribute. The XML
+  element's name, the name and the content of the
+  element's attribute are passed as String inputs.
+  The result is to print on a new line
+  a string like:
+  <Content Attribute=AttributeContent>
+  "
+  input String inContent;
+  input String Attribute;
+  input String AttributeContent;
+algorithm
+  _:=
+  matchcontinue (inContent,Attribute,AttributeContent)
+      local String inString,inAttribute,inAttributeContent;
+  case ("",_,_)  equation  Print.printBuf("");  then();
+  case (_,"",_)  equation  Print.printBuf("");  then();
+  case (_,_,"")  equation  Print.printBuf("");  then();
+  case (inString,"",_)  equation dumpStrOpenTag(inString);  then ();
+  case (inString,_,"")  equation dumpStrOpenTag(inString);  then ();
+  case (inString,inAttribute,inAttributeContent)
+    equation
+      Print.printBuf("\n<");Print.printBuf(inString);Print.printBuf(" ");Print.printBuf(Attribute);Print.printBuf("=\"");Print.printBuf(inAttributeContent);Print.printBuf("\" />");
+    then();
+  end matchcontinue;
+end dumpStrTagAttrNoChild;
+
+public function dumpSubscript "
+This function print an DAE.Subscript eventually
+using the ExpressionDump.printExpStr function.
+"
+  input DAE.Subscript inSubscript;
+algorithm
+  _:=
+  matchcontinue (inSubscript)
+    local DAE.Exp e1;
+    case (DAE.WHOLEDIM())
+      equation
+        Print.printBuf(":");
+      then
+        ();
+    case (DAE.INDEX(exp = e1))
+      equation
+        Print.printBuf(printExpStr(e1));
+      then
+        ();
+    case (DAE.SLICE(exp = e1))
+      equation
+        Print.printBuf(printExpStr(e1));
+      then
+        ();
+  end matchcontinue;
+end dumpSubscript;
+
+public function dumpTypeStr "
+This function output the Type of a variable, it could be:
+ - Integer
+ - Real
+ - Boolean
+ - String
+ - Enum
+ "
+  input BackendDAE.Type inType;
+  output String outString;
+algorithm
+  outString:=
+  match (inType)
+    local
+      DAE.Ident s1,s2,str;
+      list<DAE.Ident> l;
+    case DAE.T_INTEGER(varLst = _) then VARTYPE_INTEGER;
+    case DAE.T_REAL(varLst = _)    then VARTYPE_REAL;
+    case DAE.T_BOOL(varLst = _)    then VARTYPE_BOOLEAN;
+    case DAE.T_STRING(varLst = _)  then VARTYPE_STRING;
+    case DAE.T_ENUMERATION(names = l)
+      equation
+        s1 = stringDelimitList(l, ", ");
+        s2 = stringAppend(VARTYPE_ENUMERATION,stringAppend("(", s1));
+        str = stringAppend(s2, ")");
+      then
+        str;
+    case DAE.T_COMPLEX(complexClassType = ClassInf.EXTERNAL_OBJ(_))
+      then VARTYPE_EXTERNALOBJECT;
+  end match;
+end dumpTypeStr;
+
+public function lbinopSymbol "
+function: lbinopSymbol
+  Return string representation of logical binary operator.
+"
+  input DAE.Operator inOperator;
+  output String outString;
+algorithm
+  outString:=
+  match (inOperator)
+    local String error_msg;
+    case (DAE.AND(ty = _)) then MathMLAnd;
+    case (DAE.OR(ty = _)) then MathMLOr;
+    else
+      equation
+        error_msg = "in XMLCreateDynawo.lbinopSymbol - Unknown operator";
+        error_msg = error_msg + ExpressionDump.debugBinopSymbol(inOperator);
+        Error.addMessage(Error.INTERNAL_ERROR, {error_msg});
+      then
+        fail();
+  end match;
+end lbinopSymbol;
+
+public function lunaryopSymbol "
+function: lunaryopSymbol
+  Return string representation of logical unary operator
+  corresponding to the MathML encode.
+"
+  input DAE.Operator inOperator;
+  output String outString;
+algorithm
+  outString:=
+  match (inOperator)
+    local String error_msg;
+    case (DAE.NOT(ty = _)) then MathMLNot;
+    else
+      equation
+        error_msg = "in XMLCreateDynawo.lunaryopSymbol - Unknown operator";
+        error_msg = error_msg + ExpressionDump.debugBinopSymbol(inOperator);
+        Error.addMessage(Error.INTERNAL_ERROR, {error_msg});
+      then
+        fail();
+  end match;
+end lunaryopSymbol;
+
+public function relopSymbol "
+function: relopSymbol
+  Return string representation of function operator.
+"
+  input DAE.Operator inOperator;
+  output String outString;
+algorithm
+  outString:=
+  match (inOperator)
+    local String error_msg;
+    case (DAE.LESS(ty = _))      then MathMLLessThan;
+    case (DAE.LESSEQ(ty = _))    then MathMLLessEqualThan;
+    case (DAE.GREATER(ty = _))   then MathMLGreaterThan;
+    case (DAE.GREATEREQ(ty = _)) then MathMLGreaterEqualThan;
+    case (DAE.EQUAL(ty = _))     then MathMLEquivalent;
+    case (DAE.NEQUAL(ty = _))    then MathMLNotEqual;
+    else
+      equation
+        error_msg = "in XMLCreateDynawo.relopSymbol - Unknown operator";
+        error_msg = error_msg + ExpressionDump.debugBinopSymbol(inOperator);
+        Error.addMessage(Error.INTERNAL_ERROR, {error_msg});
+      then
+        fail();
+  end match;
+end relopSymbol;
+
+public function unaryopSymbol "
+function: unaryopSymbol
+  Return string representation of unary operators
+  corresponding to the MathML encode.
+"
+  input DAE.Operator inOperator;
+  output String outString;
+algorithm
+  outString:=
+  match (inOperator)
+    case (DAE.UMINUS(ty = _))     then MathMLMinus;
+    case (DAE.UMINUS_ARR(ty = _)) then MathMLMinus;
+  end match;
+end unaryopSymbol;
+
+//-------------------------------------
+public function unparseCommentOptionNoAnnotation "
+function: unparseCommentOptionNoAnnotation
+  Prettyprints a Comment without printing the annotation part.
+"
+  input Option<SCode.Comment> inAbsynCommentOption;
+  output String outString;
+algorithm
+  outString:= matchcontinue (inAbsynCommentOption)
+    local String str,cmt;
+    case (SOME(SCode.COMMENT(_,SOME(cmt))))
+      equation
+        //str = stringAppendList({" \"",cmt,"\""});
+        str = cmt;
+      then
+        str;
+    case (_) then "";
+  end matchcontinue;
+end unparseCommentOptionNoAnnotation;
+
+//-------------------------------------
+public function dumpStrVoidTag
+"
+This function takes as input the name
+of the void element to print and then
+print on a new line an XML code like:
+<ElementName/>
+"
+  input String inElementName;
+algorithm
+  _:=matchcontinue(inElementName)
+  local String ElementName,str2write;
+    case("") then();
+    case(ElementName)
+      equation
+        str2write = stringAppendList({"\n<",ElementName,"/>"});
+        Print.printBuf(str2write);
+      then();
+  end matchcontinue;
+end dumpStrVoidTag;
+
+//-------------------------------------
+public function dumpStrTagContent "
+  Function necessary to print an XML element
+  with a String content. The XML element's name
+  and the content are passed as String inputs.
+  The result is to print on a new line
+  a string like:
+  <inElementName>inContent</inElementName>
+  "
+  input String inElementName;
+  input String inContent;
+algorithm
+  _:=
+  matchcontinue (inElementName,inContent)
+      local String inTagString,inTagContent;
+  case ("",_)  then ();
+  case (inTagString,"")  then ();
+  case (inTagString,inTagContent)
+    equation
+      dumpStrOpenTag(inTagString);
+      Print.printBuf(stringAppend("\n",inTagContent));
+      dumpStrCloseTag(inTagString);
+    then ();
+  end matchcontinue;
+end dumpStrTagContent;
+
+//------------------------------------
+public function dumpConnectorBlock
+ "Print the line dedicated to connector as <connector name=... type=... />"
+  input String inTag;
+  input String inType;
+  input String inName;
+algorithm
+  _:= matchcontinue (inTag,inType,inName)
+      local String str2write,inName1;
+    case (_,_,"")
+     equation
+        dumpStrBlock(inTag,inType);
+     then ();
+    case (_,_,_)
+     equation
+        inName1 = Util.stringReplaceChar(inName,".","");
+        str2write = stringAppendList({"\n<",inTag," name=\"",inName1,"\" type=\"",inType,"\" ","/>"});
+        Print.printBuf(str2write);
+     then ();
+  end matchcontinue;
+end dumpConnectorBlock;
+
+//-------------------------------------
+public function dumpStrBlock
+ "Print a line such as : <intag> inString </intag>"
+  input String inTag;
+  input String inString;
+algorithm
+  _:= matchcontinue (inTag,inString)
+       local
+           String inTagString;
+           String inTagContent;
+           String str2write;
+    case ("",_) then ();
+    case (_,"") then ();
+    case (inTagString,inTagContent)
+    equation
+        str2write = stringAppendList({"\n<",inTag,">",inString,"</",inTag,">"});
+        Print.printBuf(str2write);
+    then ();
+  end matchcontinue;
+end dumpStrBlock;
+
+protected function transformModelicaIdentifierToXMLElementTag
+  input String modelicaIdentifier;
+  output String xmlElementTag;
+algorithm
+  // XML element names cannot handle $ in identifiers
+  // TODO! FIXME!, there are many other characters valid in Modelica
+  // function names and identifiers that aren't valid in XML element tags.
+  xmlElementTag := System.stringReplace(modelicaIdentifier, "$", "_dollar_");
+
+  // TODO! FIXME!, we have issues with accented chars in comments
+  // that end up in the Model_init.xml file and makes it not well
+  // formed but the line below does not work if the xmlElementTag is
+  // already UTF-8. We should somehow detect the encoding.
+  // xmlElementTag := System.iconv(xmlElementTag, "", "UTF-8");
+
+end transformModelicaIdentifierToXMLElementTag;
+
+//-------------------------------------
+public function dumpStrOpenTag "
+   Function necessary to print the begin of a new XML element <Content>
+   "
+  input String inContent;
+algorithm
+  _:=
+  matchcontinue (inContent)
+      local String inString, str2write;
+  case ("")
+    equation
+      Print.printBuf("");
+    then ();
+  case (inString)
+    equation
+      str2write = stringAppendList({"\n<",inString,">"});
+      Print.printBuf(str2write);
+    then ();
+  end matchcontinue;
+end dumpStrOpenTag;
+
+//-------------------------------------
+public function dumpStrCloseTag "
+  Function necessary to print the end of an
+  XML element. </Content> "
+  input String inContent;
+algorithm
+  _:=
+  matchcontinue (inContent)
+      local String inString,str2write;
+  case ("")
+    equation
+    then ();
+  case (inString)
+    equation
+         str2write = stringAppendList({"\n</",inString,">"});
+         Print.printBuf(str2write);
+    then ();
+  end matchcontinue;
+end dumpStrCloseTag;
+
+//-------------------------------------
+public function dumpConnectorStr "
+This function returns a string with
+the content of the connector type of a variable.
+It could be:
+ - Potential
+ - Flow
+ - Stream
+ - Non_Connector
+"
+  input DAE.ConnectorType inVarFlow;
+  output String outString;
+algorithm
+  outString:=
+  match (inVarFlow)
+    case DAE.POTENTIAL()     then VAR_CONNECTOR_POTENTIAL;
+    case DAE.FLOW()          then VAR_CONNECTOR_FLOW;
+    case DAE.STREAM()        then VAR_CONNECTOR_STREAM;
+    case DAE.NON_CONNECTOR() then VAR_CONNECTOR_NOTCONNECTOR;
+  end match;
+end dumpConnectorStr;
+
+//-------------------------------------
+protected function getConnectorName
+" Get the tackled connector name."
+      input  DAE.ElementSource source;
+      output String connectorName;
+algorithm
+ connectorName := match (source)
+    local
+      String name;
+      list<Absyn.Path> paths;
+      list<String> paths_lst;
+    case (_)
+     equation
+        paths     = ElementSource.getElementSourceTypes(source);
+        paths_lst = list(AbsynUtil.pathString(p) for p in paths);
+        name = if listLength(paths_lst) >= 2 then List.second(paths_lst) else "";
+     then
+        name;
+  end match;
+end getConnectorName;
+
+//-------------------------------------
+protected function decoupCref
+ " Get the first and the last string of a variable Component Reference"
+  input DAE.ComponentRef cr;
+  output String crStr;
+  output String varCrefStr1;
+  output String varCrefStr2;
+algorithm
+  (crStr,varCrefStr1,varCrefStr2) :=
+  matchcontinue (cr)
+    local
+       String crStr0;
+       String varCrStr1;
+       String varCrStr2;
+
+       Integer lensCref;
+       DAE.ComponentRef varCref1,varCref2,varCr2;
+       list<DAE.ComponentRef> allCrefParts;
+       list<DAE.ComponentRef> mCref;
+       list<DAE.ComponentRef> sCref;
+  case(_)
+    equation
+      varCref1 = ComponentReference.crefFirstCref(cr);
+      varCref2 = ComponentReference.crefLastCref(cr);
+
+      allCrefParts = ComponentReference.explode(cr);
+      (mCref, sCref) = List.split(allCrefParts, ComponentReference.identifierCount(varCref1));
+
+      lensCref = listLength(sCref);
+
+      crStr0    = ComponentReference.printComponentRefStr(cr);
+      varCrStr1 = ComponentReference.printComponentRefStr(varCref1);
+
+      varCr2    = if lensCref>1 then ComponentReference.implode(sCref) else varCref2;
+      varCrStr2 = ComponentReference.printComponentRefStr(varCr2);
+    then
+      (crStr0,varCrStr1,varCrStr2);
+  end matchcontinue;
+end decoupCref;
+
+//-------------------------------------
+public function writeBeginStructBlock
+   input String varCrefStr1;
+algorithm
+  _:= matchcontinue (varCrefStr1)
+     local
+       String str2write;
+    case (_)
+     equation
+      str2write = stringAppendList({"\n<",RTE_STRUCT,">"});
+      Print.printBuf(str2write);
+
+      dumpStrBlock(VAR_NAME,varCrefStr1);
+
+      str2write = stringAppendList({"\n<",RTE_SUBNODES,">"});
+      Print.printBuf(str2write);
+     then ();
+  end matchcontinue;
+end writeBeginStructBlock;
+
+//-------------------------------------
+public function writeEndStructBlock
+algorithm
+      dumpStrCloseTag(RTE_DESIGNATION_VARIABLE);
+      dumpStrCloseTag(RTE_SUBNODES);
+      dumpStrCloseTag(RTE_STRUCT);
+end writeEndStructBlock;
+
+//-------------------------------------
+public function dumpVariableRTE "
+This function print to the standard output the content of a variable.
+ In particular it takes:
+* cr   : the var name
+* kind : variable, state, dummy_der, dummy_state,..
+* varno: the variable number
+* dir  : input, output or bi-directional
+* var_type: builtin type or enumeration
+* old_name: the original name of the variable
+* varFixed: fixed attribute for variables (default fixed
+    value is used if not found. Default is true for parameters
+   (and constants) and false for variables)
+* connectorPrefix : Tells if it is a potential, flow, stream variable or not
+* connectorName   : Name of the connector
+* comment         : A comment associated to the variable.
+* isConnector     : True if the varibale belongs to a connector
+"
+  input String varno;
+  input DAE.ComponentRef cr;
+  input String kind,dir,var_type,varFixed,connectorPrefix,connectorName,comment;
+  input Boolean isConnector;
+algorithm
+  _:=
+  matchcontinue (varno,cr,kind,dir,var_type,varFixed,connectorPrefix,connectorName,comment,isConnector)
+      local
+       Boolean isConnect;
+       String str2write;
+       String crStr,varCrefStr1,varCrefStr2;
+
+    case (_,_,_,_,_,_,_,_,"",true)
+    equation
+      (crStr,varCrefStr1,varCrefStr2) = decoupCref(cr);
+
+      writeBeginStructBlock(varCrefStr1);
+
+      str2write = stringAppendList({"\n<",RTE_DESIGNATION_VARIABLE,">"});
+      Print.printBuf(str2write);
+      dumpStrBlock(VAR_NAME,varCrefStr2);
+
+      dumpStrBlock(VAR_VARIABILITY,kind);
+      dumpStrBlock(VAR_COUNT,varno);
+      dumpStrBlock(VAR_ID,crStr);
+      dumpStrBlock(VAR_TYPE,var_type);
+      dumpStrBlock(VAR_DIRECTION,dir);
+
+      dumpStrBlock(VAR_FIXED,varFixed);
+      dumpConnectorBlock(VAR_CONNECTOR,connectorPrefix,connectorName);
+
+      writeEndStructBlock();
+    then ();
+    case (_,_,_,_,_,_,_,_,_,true)
+    equation
+      (crStr,varCrefStr1,varCrefStr2) = decoupCref(cr);
+
+      writeBeginStructBlock(varCrefStr1);
+
+      str2write = stringAppendList({"\n<",RTE_DESIGNATION_VARIABLE,">"});
+      Print.printBuf(str2write);
+      dumpStrBlock(VAR_NAME,varCrefStr2);
+
+      dumpStrBlock(VAR_VARIABILITY,kind);
+      dumpStrBlock(VAR_COUNT,varno);
+      dumpStrBlock(VAR_ID,crStr);
+      dumpStrBlock(VAR_TYPE,var_type);
+      dumpStrBlock(VAR_DIRECTION,dir);
+
+      dumpStrBlock(VAR_FIXED,varFixed);
+      dumpConnectorBlock(VAR_CONNECTOR,connectorPrefix,connectorName);
+
+      dumpStrBlock(VAR_COMMENT,Util.xmlEscape(comment));
+
+      writeEndStructBlock();
+    then ();
+    case (_,_,_,_,_,_,_,_,"",false)
+    equation
+      str2write = stringAppendList({"\n<",RTE_DESIGNATION_VARIABLE,">"});
+      Print.printBuf(str2write);
+
+      dumpStrBlock(VAR_NAME,ComponentReference.printComponentRefStr(cr));
+
+      dumpStrBlock(VAR_VARIABILITY,kind);
+      dumpStrBlock(VAR_COUNT,varno);
+      dumpStrBlock(VAR_TYPE,var_type);
+      dumpStrBlock(VAR_DIRECTION,dir);
+
+      dumpStrBlock(VAR_FIXED,varFixed);
+      dumpConnectorBlock(VAR_CONNECTOR,connectorPrefix,connectorName);
+      dumpStrCloseTag(RTE_DESIGNATION_VARIABLE);
+    then();
+    case (_,_,_,_,_,_,_,_,_,false)
+    equation
+      str2write = stringAppendList({"\n<",RTE_DESIGNATION_VARIABLE,">"});
+      Print.printBuf(str2write);
+
+      dumpStrBlock(VAR_NAME,ComponentReference.printComponentRefStr(cr));
+      dumpStrBlock(VAR_VARIABILITY,kind);
+      dumpStrBlock(VAR_COUNT,varno);
+      dumpStrBlock(VAR_TYPE,var_type);
+      dumpStrBlock(VAR_DIRECTION,dir);
+
+      dumpStrBlock(VAR_FIXED,varFixed);
+      dumpConnectorBlock(VAR_CONNECTOR,connectorPrefix,connectorName);
+
+      dumpStrBlock(VAR_COMMENT,Util.xmlEscape(comment));
+      dumpStrCloseTag(RTE_DESIGNATION_VARIABLE);
+    then ();
+  end matchcontinue;
+end dumpVariableRTE;
+
+//-------------------------------------
+protected function dumpVars2RTE "
+This function is one of the two help function to the dumpVarRTE method.
+The two help functions differ from the number of the output.
+This function is used for printing the content
+of a variable with no AdditionalInfo.
+"
+  input list<BackendDAE.Var> inVarLst;
+  input Integer inInteger;
+algorithm
+  _ := match (inVarLst,inInteger)
+    local
+      Integer varno;
+
+      Integer var_1;
+      BackendDAE.Var v;
+      list<BackendDAE.Var> varsLst;
+
+      String connectorName;
+      DAE.ComponentRef   cr;
+      Option<DAE.Exp> e;
+      Option<DAE.VariableAttributes> dae_var_attr;
+      BackendDAE.VarKind kind;
+      DAE.VarDirection   dir;
+      BackendDAE.Type    var_type;
+      DAE.ElementSource  source    "The element origin";
+      Option<SCode.Comment> comment;
+      DAE.ConnectorType    ct;
+      list<Absyn.Path> paths;
+      list<String> paths_lst;
+
+    case ({},_) then ();
+
+    case (((v as BackendDAE.VAR(varName = cr,
+                            varKind = kind,
+                            varDirection = dir,
+                            varType = var_type,
+                            bindExp = e,
+                            source = source,
+                            values = dae_var_attr,
+                            comment = comment,
+                            connectorType = ct)) :: varsLst),varno)
+      equation
+        connectorName = getConnectorName(source);
+
+        //... Dump one variable
+        dumpVariableRTE(intString(varno),cr,
+                        dumpKind(kind),dumpDirectionStr(dir),dumpTypeStr(var_type),
+                        boolString(BackendVariable.varFixed(v)),
+                        dumpConnectorStr(ct),connectorName,
+                        unparseCommentOptionNoAnnotation(comment),
+                        BackendVariable.isVarConnector(v));
+
+        var_1 = varno + 1;
+        dumpVars2RTE(varsLst,var_1);
+      then ();
+  end match;
+end dumpVars2RTE;
+
+//-------------------------------------
+public function dumpVarsRTE "
+This function prints a list of Var in a XML format.
+If the list is not empty (in that case nothing is printed)
+the output is:
+  <elements DIMENSION= ...>
+        ...
+  </elements>
+"
+  input list<BackendDAE.Var> vars;
+algorithm
+  _ := matchcontinue (vars)
+    local
+      Integer len,iNextAD;
+    case ({})
+      then ();
+    case (_)
+      equation
+        len = listLength(vars);
+        len >= 1 = true;
+
+        //... Dump all the model variables
+        dumpStrOpenTagAttr(RTE_VARIABLES_LIST,DIMENSION,intString(len));
+
+        iNextAD = 1;
+        dumpVars2RTE(vars,iNextAD);
+
+        dumpStrCloseTag(RTE_VARIABLES_LIST);
+      then ();
+  end matchcontinue;
+end dumpVarsRTE;
+
+//-------------------------------------
+public function printStrCref "print StrCref."
+  input list<String> inStrCR;
+algorithm
+  _ := List.fold(inStrCR, printStrCref1, 1);
+end printStrCref;
+//-------------------------------------
+protected function printStrCref1
+  input  String inStrCR;
+  input  Integer inVarNo;
+  output Integer outVarNo;
+algorithm
+  printStrCref2(inStrCR);
+  outVarNo := inVarNo + 1;
+end printStrCref1;
+//-------------------------------------
+public function printStrCref2
+  input String inStrCR;
+algorithm
+  _ := matchcontinue (inStrCR)
+      local String CR1;
+  case("") then ();
+  case(CR1)
+   equation
+      print(CR1 + "\n");
+   then ();
+  end matchcontinue;
+end printStrCref2;
+
+//-------------------------------------
+public function printVarCref "print VarCref."
+  input list<DAE.ComponentRef> inCR;
+algorithm
+  _ := List.fold(inCR, printVarCref1, 1);
+end printVarCref;
+//-------------------------------------
+protected function printVarCref1
+  input DAE.ComponentRef inCR;
+  input  Integer inVarNo;
+  output Integer outVarNo;
+algorithm
+  print(intString(inVarNo));
+  print(": ");
+  print(ComponentReference.printComponentRefStr(inCR) + "\n");
+  outVarNo := inVarNo + 1;
+end printVarCref1;
+
+//-------------------------------------
+protected function getCrefs
+  input list<BackendDAE.Var> inVars;
+  input  list<DAE.ComponentRef> inCR;
+  output list<DAE.ComponentRef> outCR;
+algorithm
+  outCR := match(inVars,inCR)
+    local
+      BackendDAE.Var v1;
+      list<BackendDAE.Var> tail;
+      DAE.ComponentRef lCR;
+    case ({},_) then inCR;
+    case (v1 :: tail,_)
+    equation
+      lCR = BackendVariable.varCref(v1);
+      then getCrefs(tail,listAppend(inCR,{lCR}));
+  end match;
+end getCrefs;
+
+//-------------------------------------
+protected function sortCrefs_RTE
+  input  list<BackendDAE.Var> inVars;
+  input  list<String> inStrCR;
+  output list<String> outStrConnectorCref;
+algorithm
+  outStrConnectorCref := matchcontinue (inVars,inStrCR)
+     local
+      BackendDAE.Var v1;
+      list<BackendDAE.Var> tail1;
+      DAE.ComponentRef cr1;
+      String selectCR;
+    case ({},_) then inStrCR;
+    case (v1 :: tail1,_)
+      equation
+       cr1 = BackendVariable.varCref(v1);
+       selectCR = if BackendVariable.isVarConnector(v1) then ComponentReference.printComponentRefStr(cr1) else "";
+      //then sortCrefs_RTE(tail1,listAppend(inStrCR,{selectCR}));
+      then sortCrefs_RTE(tail1,selectCR :: inStrCR);
+  end matchcontinue;
+end sortCrefs_RTE;
+
+//-------------------------------------
+protected function getVars_RTE
+  input  BackendDAE.EqSystem syst;
+  input  list<BackendDAE.Var> inVars;
+  output list<BackendDAE.Var> outVars;
+protected
+  list<BackendDAE.Var> vars;
+algorithm
+  //local integer n;
+  vars := BackendVariable.varList(BackendVariable.daeVars(syst));
+  //n  := numVariables(vars);
+  outVars := listAppend(inVars,vars);
+end getVars_RTE;
+
+//-------------------------------------
+public function createDAE2Dynawo "
+  This function dumps all variables of BackendDAE representation to stdout as XML format.
+"
+  input BackendDAE.BackendDAE inBackendDAE;
+  input String                modelName;
+algorithm
+  _ := matchcontinue (inBackendDAE,modelName)
+    local
+      list<BackendDAE.EqSystem> systs;
+      String  cName;
+
+      list<BackendDAE.Var>   vars;
+      list<DAE.ComponentRef> vars_cref;
+      list<String>           connectorCref;
+      list<list<String>>     connectorCref2;
+      list<Integer>          subNodeCref;
+
+      //Known Variables: constant & parameter variables.
+      BackendDAE.Variables vars_globalKnownVars;
+      BackendDAE.Variables vars_localKnownVars;
+      array<list<BackendDAE.CrefIndex>> crefIdxLstArr_globalKnownVars;
+      array<list<BackendDAE.CrefIndex>> crefIdxLstArr_localKnownVars;
+      BackendDAE.VariableArray varArr_globalKnownVars;
+      BackendDAE.VariableArray varArr_localKnownVars;
+      Integer bucketSize_globalKnownVars;
+      Integer bucketSize_localKnownVars;
+      Integer numberOfVars_globalKnownVars;
+      Integer numberOfVars_localKnownVars;
+
+      //External Object: external variables.
+      list<BackendDAE.Var> extvars;
+      BackendDAE.Variables vars_externalObject;
+      array<list<BackendDAE.CrefIndex>> crefIdxLstArr_externalObject;
+      BackendDAE.VariableArray varArr_externalObject;
+      Integer bucketSize_externalObject;
+      Integer numberOfVars_externalObject;
+
+      //Alias Variables: alias variables
+      list<BackendDAE.Var> aliasvars;
+      BackendDAE.Variables vars_aliasVars;
+      array<list<BackendDAE.CrefIndex>> crefIdxLstArr_aliasVars;
+      BackendDAE.VariableArray varArr_aliasVars;
+      Integer bucketSize_aliasVars;
+      Integer numberOfVars_aliasVars;
+
+      //External Classes
+      BackendDAE.ExternalObjectClasses extObjCls;
+
+      BackendDAE.EquationArray reqns,ieqns;
+      list<DAE.Constraint> constrs;
+      list<DAE.ClassAttributes> clsAttrs;
+
+      BackendDAE.BackendDAEType    btp;
+      BackendDAE.SymbolicJacobians symjacs;
+      DAE.FunctionTree             funcs;
+      BackendDAE.EventInfo         eventInfo;
+
+    case (BackendDAE.DAE(systs,
+                 BackendDAE.SHARED(
+                 vars_globalKnownVars as BackendDAE.VARIABLES(crefIndices=crefIdxLstArr_globalKnownVars,varArr=varArr_globalKnownVars,bucketSize=bucketSize_globalKnownVars,numberOfVars=numberOfVars_globalKnownVars),
+                 vars_localKnownVars as BackendDAE.VARIABLES(crefIndices=crefIdxLstArr_localKnownVars,varArr=varArr_localKnownVars,bucketSize=bucketSize_localKnownVars,numberOfVars=numberOfVars_localKnownVars),
+                 vars_externalObject as BackendDAE.VARIABLES(crefIndices=crefIdxLstArr_externalObject,varArr=varArr_externalObject,bucketSize=bucketSize_externalObject,numberOfVars=numberOfVars_externalObject),
+                 vars_aliasVars as BackendDAE.VARIABLES(crefIndices=crefIdxLstArr_aliasVars,varArr=varArr_aliasVars,bucketSize=bucketSize_aliasVars,numberOfVars=numberOfVars_aliasVars),
+                 ieqns,reqns,constrs,clsAttrs,_,_,funcs,eventInfo,extObjCls,btp,symjacs,_)),
+                 cName)
+      equation
+        //... Get all the variables
+        vars = List.fold(systs,getVars_RTE,{});
+
+        //... Get all the variables Component Reference
+        vars_cref = getCrefs(vars,{});
+
+        //... Verification printing
+
+        //... Select the variables Component References
+        connectorCref  = sortCrefs_RTE(vars,{});
+        connectorCref  = listReverse(connectorCref);
+
+        //... Building of the specific XML file
+        Print.printBuf(HEADER);
+        dumpStrOpenTag(RTE_OPEN);
+
+        //... Information about modelName
+        dumpStrBlock(RTE_MODELNAME,cName);
+
+        dumpVarsRTE(vars);
+
+        dumpStrCloseTag(RTE_CLOSE);
+      then ();
+    else
+      equation
+        Error.addMessage(Error.INTERNAL_ERROR, {"XMLCreateDynawo.createDAE2Dynawo failed"});
+      then
+        fail();
+  end matchcontinue;
+end createDAE2Dynawo;
+
+//================================================================================
+//   A.D :  Programmation en cours pour regroupement des struct => A debbuger
+//================================================================================
+//-------------------------------------
+// ===> Programmation pour obtenir la liste d'entiers
+        //subNodeCref = countStrCref(connectorCref,{});
+
+//-------------------------------------
+public function getCountBefore
+  input  list<Integer> indexList;
+  output Integer nbCrefPrevious;
+algorithm
+ nbCrefPrevious := matchcontinue(indexList)
+  case({}) then 1;
+  case(_)  then List.last(indexList);
+ end matchcontinue;
+end getCountBefore;
+
+//-------------------------------------
+public function countStrCref "Specific count about StrCref."
+  input  list<String> inList;
+  input  list<Integer> indexList;
+  output list<Integer> outList;
+algorithm
+  outList := matchcontinue(inList,indexList)
+    local
+       String elem;
+       list<String> tail;
+
+       Integer nbCref,nbCrefPrevious,elemPosition1;
+       list<Integer> nbCrefIndex;
+       list<String> inList2;
+    case({},_)
+       then {};
+    case(elem :: tail,_)
+     equation
+       nbCrefPrevious = getCountBefore(indexList);
+
+       print("3\n");
+       elemPosition1 = List.position(elem,tail);
+
+       print("4\n");
+       elemPosition1 = elemPosition1 + 1;
+
+       inList2  = if stringEqual(elem,List.last(tail)) then {} else List.lastN(tail,elemPosition1);
+
+       print("4.1\n");
+       nbCrefIndex = count3(inList2,elem,{});
+
+       nbCref = count2(nbCrefPrevious,nbCrefIndex);
+       print("5\n");
+     then
+        countStrCref(tail,listAppend(indexList,{nbCref}));
+  end matchcontinue;
+end countStrCref;
+
+public function count2
+  input Integer nbCrefPrevious;
+  input list<Integer> nbCrefIndex;
+  output Integer nbCref;
+algorithm
+   nbCref := matchcontinue(nbCrefPrevious,nbCrefIndex)
+      local
+         Integer n,nout;
+         Integer n1;
+         Integer n2;
+    case(n,{})
+      then 1;
+    case(n,_)
+      equation
+       print("4.2\n");
+       n2 = if n == 1 or n == -1 then List.reduce(nbCrefIndex,intAdd) else 1;
+       n1 = if n<0 and n<-1 then n+1 else n2;
+       nout = if n > 1 then -n+1 else  n1;
+       print("4.3\n");
+      then
+         nout;
+    end matchcontinue;
+end count2;
+
+public function count3
+   input  list<String> inList;
+   input  String strCrefToCompare;
+   input  list<Integer> nbCrefLst;
+   output list<Integer> nbCref;
+algorithm
+  nbCref := matchcontinue(inList,strCrefToCompare,nbCrefLst)
+     local
+        Integer nbFirstCref;
+        list<String> strCrefIndxLst;
+        String  strCrefIndx,elem;
+        list<String> tail;
+    case({},_,_)
+     then {};
+    case(elem :: tail,_,_)
+     equation
+       print("4.1.1\n");
+       //strCrefIndx = listGet(elem,1);
+       strCrefIndxLst = Util.stringSplitAtChar(elem,".");
+       strCrefIndx = listGet(strCrefIndxLst,1);
+       print("4.1.2\n");
+       nbFirstCref = if stringEqual(strCrefToCompare,strCrefIndx) then 1 else 0;
+       print("4.1.3\n");
+     then count3(tail,strCrefToCompare,listAppend(nbCrefLst,{nbFirstCref}));
+ end matchcontinue;
+end count3;
+
+
+annotation(__OpenModelica_Interface="backend");
+end XMLCreateDynawo;
diff --git a/OMCompiler/Compiler/FrontEnd/ModelicaBuiltin.mo b/OMCompiler/Compiler/FrontEnd/ModelicaBuiltin.mo
index 3e0cb06020..dbc3cbd67d 100644
--- a/OMCompiler/Compiler/FrontEnd/ModelicaBuiltin.mo
+++ b/OMCompiler/Compiler/FrontEnd/ModelicaBuiltin.mo
@@ -2216,6 +2216,17 @@ annotation(Documentation(info="<html>
 </html>"),preferredView="text");
 end dumpXMLDAE;
 
+function createXML2RTE "Outputs the DAE system corresponding to a specific RTE model"
+   input TypeName className;
+   input String   rewriteRulesFile = ""  "The file from where the rewiteRules are read, default is empty which means no rewrite rules";
+
+   output Boolean success    "If the function succeeded true/false";
+   output String xmlfileName "The output specific XML file";
+external "builtin";
+annotation(preferredView="text");
+end createXML2RTE;
+
+
 function convertUnits
   input String s1;
   input String s2;
diff --git a/OMCompiler/Compiler/NFFrontEnd/NFModelicaBuiltin.mo b/OMCompiler/Compiler/NFFrontEnd/NFModelicaBuiltin.mo
index c1778febfe..f8e74e81c1 100644
--- a/OMCompiler/Compiler/NFFrontEnd/NFModelicaBuiltin.mo
+++ b/OMCompiler/Compiler/NFFrontEnd/NFModelicaBuiltin.mo
@@ -2459,6 +2459,16 @@ annotation(Documentation(info="<html>
 </html>"),preferredView="text");
 end dumpXMLDAE;
 
+function createXML2RTE "Outputs the DAE system corresponding to a specific RTE model"
+   input TypeName className;
+   input String   rewriteRulesFile = ""  "The file from where the rewiteRules are read, default is empty which means no rewrite rules";
+
+   output Boolean success    "If the function succeeded true/false";
+   output String xmlfileName "The output specific XML file";
+external "builtin";
+annotation(preferredView="text");
+end createXML2RTE;
+
 function convertUnits
   input String s1;
   input String s2;
diff --git a/OMCompiler/Compiler/Script/CevalScriptBackend.mo b/OMCompiler/Compiler/Script/CevalScriptBackend.mo
index ff8e494a27..41d21e9837 100644
--- a/OMCompiler/Compiler/Script/CevalScriptBackend.mo
+++ b/OMCompiler/Compiler/Script/CevalScriptBackend.mo
@@ -139,6 +139,7 @@ import UnitAbsynBuilder;
 import UnitParserExt;
 import Util;
 import ValuesUtil;
+import XMLCreateDynawo;
 import XMLDump;
 
 
@@ -3056,8 +3057,18 @@ algorithm
 
     case ("dumpXMLDAE",_)
       then
-        ValuesUtil.makeTuple({Values.BOOL(false),Values.STRING("")});
+        ValuesUtil.makeTuple({Values.BOOL(false),Values.STRING("")});    
+        
+    case ("createXML2RTE",vals)
+      equation
+        (outCache,xml_filename) = createXML2RTE(outCache,inEnv,vals,msg);
+      then
+        ValuesUtil.makeTuple({Values.BOOL(true),Values.STRING(xml_filename)});
 
+    case ("createXML2RTE",_)
+      then
+        ValuesUtil.makeTuple({Values.BOOL(false),Values.STRING("New openModelica API : Xml creation for Dynawo error.")});    
+        
     case ("solveLinearSystem",{Values.ARRAY(valueLst=vals),v,Values.ENUM_LITERAL(index=1 /*dgesv*/),Values.ARRAY(valueLst={Values.INTEGER(-1)})})
       equation
         (realVals,i) = System.dgesv(List.map(vals,ValuesUtil.arrayValueReals),ValuesUtil.arrayValueReals(v));
@@ -6151,6 +6162,116 @@ algorithm
   end matchcontinue;
 end dumpXMLDAE;
 
+protected function createXMLDAE2DynawoFrontEnd
+" This function runs the front-end for the createXML2RTE function"
+  input output FCore.Cache inCache;
+  input output FCore.Graph inEnv;
+  input list<Values.Value> vals;
+  output DAE.DAElist dae;
+algorithm
+  (inCache,inEnv, dae) :=
+  matchcontinue (inCache,inEnv,vals)
+    local
+      Absyn.Program p;
+      SCode.Program scode;
+      String filenameprefix,rewriteRulesFile;
+      Absyn.Path classname;
+      Boolean addOriginalAdjacencyMatrix,addSolvingInfo,addMathMLCode,dumpResiduals;
+
+    case (_, _, {Values.CODE(Absyn.C_TYPENAME(classname)),Values.STRING(rewriteRulesFile)})
+      equation
+        // set the rewrite rules flag
+        FlagsUtil.setConfigString(Flags.REWRITE_RULES_FILE, rewriteRulesFile);
+        // load the rewrite rules
+        RewriteRules.loadRules();
+
+        (inCache, inEnv, _, dae) = Inst.instantiateClass(inCache, InnerOuter.emptyInstHierarchy, SymbolTable.getSCode(), classname);
+
+        dae = DAEUtil.transformationsBeforeBackend(inCache,inEnv,dae);
+
+        // clear the rewrite rules after running the front-end
+        FlagsUtil.setConfigString(Flags.REWRITE_RULES_FILE, "");
+        RewriteRules.clearRules();
+     then
+       (inCache, inEnv, dae);
+
+    case (_, _, _)
+      equation
+        // clear the rewrite rules if we fail!
+        FlagsUtil.setConfigString(Flags.REWRITE_RULES_FILE, "");
+        RewriteRules.clearRules();
+     then
+       fail();
+  end matchcontinue;
+end createXMLDAE2DynawoFrontEnd;
+
+protected function createXML2RTE
+" This function outputs the DAE system corresponding to a RTR specific model."
+  input FCore.Cache inCache;
+  input FCore.Graph inEnv;
+  input list<Values.Value> vals;
+  input Absyn.Msg inMsg;
+
+  output FCore.Cache outCache;
+  output String xml_filename "Output specific XML fileName";
+algorithm
+  (outCache,xml_filename) :=
+  match (inCache,inEnv,vals,inMsg)
+    local
+      FCore.Cache cache;
+      FCore.Graph env;
+      DAE.DAElist dae;
+      BackendDAE.BackendDAE dlow;
+
+      Absyn.Path classname;
+      String rewriteRulesFile;
+      GlobalScript.SymbolTable st;
+      Absyn.Msg msg;
+
+      String cname_str,compileDir,description;
+
+    case (cache,env,
+          {Values.CODE(Absyn.C_TYPENAME(classname)),Values.STRING(rewriteRulesFile)},
+          msg)
+      equation
+	      // Initialisations
+        //~~~~~~~~~~~~~~~~
+        System.startTimer();
+	      Error.clearMessages() "Clear messages";
+
+        compileDir = System.pwd() + Autoconf.pathDelimiter;
+        cname_str  = AbsynUtil.pathString(classname);
+
+	      // Generation of the DAE structure
+        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+        (outCache, env, dae) = createXMLDAE2DynawoFrontEnd(cache, inEnv, vals);
+
+        // Generation of the DAE Lower structure
+        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	      description = DAEUtil.daeDescription(dae);
+        dlow = BackendDAECreate.lower(dae,cache,env,BackendDAE.EXTRA_INFO(description,cname_str));
+
+        // Call of the new Metamodelica sub-method
+        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+        Print.clearBuf();
+        XMLCreateDynawo.createDAE2Dynawo(dlow,cname_str);
+
+        // Complete generation of the output XML file
+        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+        xml_filename = stringAppendList({cname_str,"_structure.xml"});
+        Print.writeBuf(xml_filename);
+
+        Print.clearBuf();
+        compileDir = if Testsuite.isRunning() then "" else compileDir;
+        System.stopTimer();
+      then
+        (cache,stringAppendList({compileDir,xml_filename}));
+
+  end match;
+end createXML2RTE;
+
+
+
 protected function applyRewriteRulesOnBackend
   input BackendDAE.BackendDAE inBackendDAE;
   output BackendDAE.BackendDAE outBackendDAE;
diff --git a/OMCompiler/Compiler/SimCode/SimCodeUtil.mo b/OMCompiler/Compiler/SimCode/SimCodeUtil.mo
index 032d59bee2..306d310bfc 100644
--- a/OMCompiler/Compiler/SimCode/SimCodeUtil.mo
+++ b/OMCompiler/Compiler/SimCode/SimCodeUtil.mo
@@ -8545,12 +8545,27 @@ algorithm
     case SOME(bval) then (if bval then " hideResult " else "");
     else "";
   end match);
+  s := s + ("valueType: "+DaeTypeToStr(inVar.type_));
   s := s + " initial: " + (if Util.isSome(inVar.initialValue) then ExpressionDump.printOptExpStr(inVar.initialValue) else "");
   s := s + (if Util.isSome(inVar.arrayCref) then "\tarrCref:" + ComponentReference.printComponentRefStr(Util.getOption(inVar.arrayCref)) else "\tno arrCref");
   s := s + " index:(" + (if Util.isSome(inVar.variable_index) then intString(Util.getOption(inVar.variable_index)) else "") + ")";
   s := s + " [" + stringDelimitList(inVar.numArrayElement, ",") + "]";
 end simVarString;
 
+public function DaeTypeToStr
+  input DAE.Type type_;
+  output String s;
+algorithm
+  s := match(type_)
+    case  DAE.T_INTEGER() then "integer";
+    case  DAE.T_REAL() then "real";
+    case  DAE.T_STRING() then "string";
+    case  DAE.T_BOOL() then "boolean";
+    case  DAE.T_ENUMERATION() then "enumeration";
+    else then "others";
+    end match;
+end DaeTypeToStr;
+
 public function dumpVarLst"dumps a list of SimVars to stdout.
 author:Waurich TUD 2014-05"
   input list<SimCodeVar.SimVar> varLst;
@@ -8566,6 +8581,21 @@ algorithm
   end if;
 end dumpVarLst;
 
+public function dumpVarLstFile"dumps a list of SimVars to a file."
+    input list<SimCodeVar.SimVar> varLst;
+    input String header;
+    input File.File file;
+protected
+    SimCodeVar.SimVar var;
+algorithm
+    if not listEmpty(varLst) then
+       File.write(file,"//"+header+"\n//----------------------\n");
+      for var in varLst loop
+         File.write(file, "type: " + header +" " + simVarString(var)+"\n");
+      end for;
+    end if;
+end dumpVarLstFile;
+
 public function printVarLstCrefs
     input list<SimCodeVar.SimVar> inVars;
     output String str;
@@ -8653,6 +8683,59 @@ algorithm
   dumpFunctions(functions);
 end dumpModelInfo;
 
+public function dumpModelInfoToFile"dumps the SimVars to stdout
+author:Waurich TUD 2014-05"
+  input SimCode.ModelInfo modelInfo;
+protected
+  Integer nsv,nalgv;
+  SimCode.VarInfo varInfo;
+  SimCodeVar.SimVars simVars;
+  list<SimCodeVar.SimVar> stateVars;
+  list<SimCodeVar.SimVar> derivativeVars;
+  list<SimCodeVar.SimVar> algVars;
+  list<SimCodeVar.SimVar> discreteAlgVars;
+  list<SimCodeVar.SimVar> intAlgVars;
+  list<SimCodeVar.SimVar> boolAlgVars;
+  list<SimCodeVar.SimVar> aliasVars;
+  list<SimCodeVar.SimVar> intAliasVars;
+  list<SimCodeVar.SimVar> boolAliasVars;
+  list<SimCodeVar.SimVar> paramVars;
+  list<SimCodeVar.SimVar> boolParamVars;
+  list<SimCodeVar.SimVar> intParamVars;
+  list<SimCodeVar.SimVar> stringParamVars;
+  list<SimCodeVar.SimVar> extObjVars;
+  list<SimCodeVar.SimVar> constVars;
+  list<SimCodeVar.SimVar> intConstVars;
+  list<SimCodeVar.SimVar> stringConstVars;
+  list<SimCodeFunction.Function> functions;
+  File.File file = File.File();
+algorithm
+  File.open(file,AbsynUtil.pathString(modelInfo.name)+"_variables.txt",File.Mode.Write);
+  SimCode.MODELINFO(vars=simVars, varInfo=varInfo, functions=functions) := modelInfo;
+  SimCodeVar.SIMVARS(stateVars=stateVars,derivativeVars=derivativeVars,algVars=algVars,boolAlgVars=boolAlgVars,intAlgVars=intAlgVars,discreteAlgVars=discreteAlgVars,aliasVars=aliasVars,intAliasVars=intAliasVars,boolAliasVars=boolAliasVars,
+  paramVars=paramVars,intParamVars=intParamVars,boolParamVars=boolParamVars, stringParamVars=stringParamVars, extObjVars=extObjVars,constVars=constVars,intConstVars=intConstVars,stringConstVars=stringConstVars) := simVars;
+  SimCode.VARINFO(numStateVars=nsv,numAlgVars=nalgv) := varInfo;
+  dumpVarLstFile(stateVars,"stateVars ("+intString(nsv)+")", file);
+  dumpVarLstFile(derivativeVars,"derivativeVars", file);
+  dumpVarLstFile(algVars,"algVars ("+intString(nalgv)+")", file);
+  dumpVarLstFile(discreteAlgVars,"discreteAlgVars", file);
+  dumpVarLstFile(intAlgVars,"intAlgVars", file);
+  dumpVarLstFile(boolAlgVars,"boolAlgVars", file);
+  dumpVarLstFile(aliasVars,"aliasVars", file);
+  dumpVarLstFile(intAliasVars,"intAliasVars", file);
+  dumpVarLstFile(boolAliasVars,"boolAliasVars", file);
+  dumpVarLstFile(paramVars,"paramVars", file);
+  dumpVarLstFile(intParamVars,"intParamVars", file);
+  dumpVarLstFile(boolParamVars,"boolParamVars", file);
+  dumpVarLstFile(stringParamVars,"stringParamVars", file);
+  dumpVarLstFile(extObjVars,"extObjVars", file);
+  dumpVarLstFile(constVars,"constVars", file);
+  dumpVarLstFile(intConstVars,"intConstVars", file);
+  dumpVarLstFile(stringConstVars,"stringConstVars", file);
+end dumpModelInfoToFile;
+
+
+
 protected function dumpFunctions
   input list<SimCodeFunction.Function> functions;
 algorithm
@@ -9179,6 +9262,7 @@ algorithm
   List.map_0(jacObs,dumpJacobianMatrix);
   print("\nmodelInfo:\n" + UNDERLINE + "\n");
   dumpModelInfo(simCode.modelInfo);
+  dumpModelInfoToFile(simCode.modelInfo);
   dumpSimCodeDAEmodeDataString(simCode.daeModeData);
 end dumpSimCodeDebug;
 
diff --git a/OMCompiler/Compiler/Template/CodegenCFunctions.tpl b/OMCompiler/Compiler/Template/CodegenCFunctions.tpl
index 0feec88e4e..d33da95dcd 100644
--- a/OMCompiler/Compiler/Template/CodegenCFunctions.tpl
+++ b/OMCompiler/Compiler/Template/CodegenCFunctions.tpl
@@ -5572,13 +5572,7 @@ case BINARY(__) then
   case POW(__) then
     if isHalf(exp2) then
       let tmp = tempDecl(expTypeFromExpModelica(exp1),&varDecls)
-      let cstr = ExpressionDumpTpl.dumpExp(exp1,"\"")
-      let &preExp +=
-        <<
-        <%tmp%> = <%e1%>;
-        <%assertCommonVar('<%tmp%> >= 0.0', '"Model error: Argument of sqrt(<%Util.escapeModelicaStringToCString(cstr)%>) was %g should be >= 0", <%tmp%>', context, &varDecls, dummyInfo)%>
-        >>
-      'sqrt(<%tmp%>)'
+      'sqrt(<%e1%>)'
     else match realExpIntLit(exp2)
       case SOME(2) then
         let tmp = tempDecl("modelica_real", &varDecls)
@@ -5597,72 +5591,7 @@ case BINARY(__) then
           >>
         '(<%tmp%> * <%tmp%>)'
       case SOME(i) then 'real_int_pow(threadData, <%e1%>, <%i%>)'
-      else
-        let tmp1 = tempDecl("modelica_real", &varDecls)
-        let tmp2 = tempDecl("modelica_real", &varDecls)
-        let tmp3 = tempDecl("modelica_real", &varDecls)
-        let tmp4 = tempDecl("modelica_real", &varDecls) //fractpart
-        let tmp5 = tempDecl("modelica_real", &varDecls) //intpart
-        let tmp6 = tempDecl("modelica_real", &varDecls) //intpart
-        let tmp7 = tempDecl("modelica_real", &varDecls) //fractpart
-        let &preExp +=
-          <<
-          <%tmp1%> = <%e1%>;
-          <%tmp2%> = <%e2%>;
-          if(<%tmp1%> < 0.0 && <%tmp2%> != 0.0)
-          {
-            <%tmp4%> = modf(<%tmp2%>, &<%tmp5%>);
-
-            if(<%tmp4%> > 0.5)
-            {
-              <%tmp4%> -= 1.0;
-              <%tmp5%> += 1.0;
-            }
-            else if(<%tmp4%> < -0.5)
-            {
-              <%tmp4%> += 1.0;
-              <%tmp5%> -= 1.0;
-            }
-
-            if(fabs(<%tmp4%>) < 1e-10)
-              <%tmp3%> = pow(<%tmp1%>, <%tmp5%>);
-            else
-            {
-              <%tmp7%> = modf(1.0/<%tmp2%>, &<%tmp6%>);
-              if(<%tmp7%> > 0.5)
-              {
-                <%tmp7%> -= 1.0;
-                <%tmp6%> += 1.0;
-              }
-              else if(<%tmp7%> < -0.5)
-              {
-                <%tmp7%> += 1.0;
-                <%tmp6%> -= 1.0;
-              }
-              if(fabs(<%tmp7%>) < 1e-10 && ((unsigned long)<%tmp6%> & 1))
-              {
-                <%tmp3%> = -pow(-<%tmp1%>, <%tmp4%>)*pow(<%tmp1%>, <%tmp5%>);
-              }
-              else
-              {
-                <%if acceptMetaModelicaGrammar()
-                  then '<%generateThrow()%>;<%\n%>'
-                  else 'throwStreamPrint(threadData, "%s:%d: Invalid root: (%g)^(%g)", __FILE__, __LINE__, <%tmp1%>, <%tmp2%>);<%\n%>'%>
-              }
-            }
-          }
-          else
-          {
-            <%tmp3%> = pow(<%tmp1%>, <%tmp2%>);
-          }
-          if(isnan(<%tmp3%>) || isinf(<%tmp3%>))
-          {
-            <%if acceptMetaModelicaGrammar()
-              then '<%generateThrow()%>;<%\n%>'
-              else 'throwStreamPrint(threadData, "%s:%d: Invalid root: (%g)^(%g)", __FILE__, __LINE__, <%tmp1%>, <%tmp2%>);<%\n%>'%>
-          }
-          >>
-        '<%tmp3%>'
+      else 'pow(<%e1%>, <%e2%>)'
 
   case UMINUS(__) then daeExpUnary(exp, context, &preExp, &varDecls, &auxFunction)
   case ADD_ARR(__) then
@@ -6086,7 +6015,7 @@ case IFEXP(__) then
   let eThen = daeExp(expThen, context, &preExpThen, &varDecls, &auxFunction)
   let &preExpElse = buffer ""
   let eElse = daeExp(expElse, context, &preExpElse, &varDecls, &auxFunction)
-  let shortIfExp = if preExpThen then "" else if preExpElse then "" else if isArrayType(typeof(exp)) then "" else if isRecordType(typeof(exp)) then "" else "x"
+  let shortIfExp = ""
   (if shortIfExp then
       // Safe to do if eThen and eElse don't emit pre-expressions
       '(<%condExp%>?<%eThen%>:<%eElse%>)'
diff --git a/OMCompiler/Compiler/boot/LoadCompilerSources.mos b/OMCompiler/Compiler/boot/LoadCompilerSources.mos
index 824c555fb7..7cce67c4bd 100644
--- a/OMCompiler/Compiler/boot/LoadCompilerSources.mos
+++ b/OMCompiler/Compiler/boot/LoadCompilerSources.mos
@@ -243,6 +243,7 @@ if true then /* Suppress output */
     "../BackEnd/Causalize.mo",
     "../BackEnd/CommonSubExpression.mo",
     "../BackEnd/DAEQuery.mo",
+    "../BackEnd/XMLCreateDynawo.mo",
     "../BackEnd/DAEMode.mo",
     "../BackEnd/DataReconciliation.mo",
     "../BackEnd/Differentiate.mo",
diff --git a/OMCompiler/SimulationRuntime/c/simulation_data.h b/OMCompiler/SimulationRuntime/c/simulation_data.h
index 4fe412a0a1..be1f13ba3d 100644
--- a/OMCompiler/SimulationRuntime/c/simulation_data.h
+++ b/OMCompiler/SimulationRuntime/c/simulation_data.h
@@ -717,7 +717,10 @@ typedef struct SIMULATION_INFO
   modelica_string* stringVarsOld;
 
   modelica_real* realVarsPre;
+  modelica_real* discreteVarsPre;
   modelica_integer* integerVarsPre;
+  modelica_real* integerDoubleVarsPre;
+  modelica_real* derivativesVarsPre;
   modelica_boolean* booleanVarsPre;
   modelica_string* stringVarsPre;
 
@@ -766,6 +769,9 @@ typedef struct SIMULATION_DATA
   modelica_real timeValue;
 
   modelica_real* realVars;
+  modelica_real* discreteVars;
+  modelica_real* derivativesVars;
+  modelica_real* integerDoubleVars;
   modelica_integer* integerVars;
   modelica_boolean* booleanVars;
   modelica_string* stringVars;
diff --git a/configure.ac b/configure.ac
index 20e0d801f5..5265385171 100644
--- a/configure.ac
+++ b/configure.ac
@@ -70,7 +70,7 @@ if test ! -z "$USE_CORBA"; then
   CORBA_TARGETS="OMOptim-omoptim"
 fi
 
-for dir_target in OMCompiler-omc OMPlot-omplot OMEdit-omedit OMNotebook-omnotebook OMShell-omshell OMSens_Qt-omsens_qt $CORBA_TARGETS; do
+for dir_target in OMCompiler-omc $CORBA_TARGETS; do
   dir=`echo $dir_target | cut -d- -f1`
   if test ! -f "$dir/configure.ac"; then
     AC_MSG_NOTICE("Subproject $dir does not exist")
@@ -88,7 +88,7 @@ if test -f testsuite/Makefile; then
 fi
 
 
-AC_CONFIG_SUBDIRS([OMCompiler OMPlot OMEdit OMNotebook OMShell OMSens_Qt])
+AC_CONFIG_SUBDIRS([OMCompiler])
 if test ! -z "$USE_CORBA"; then
   AC_CONFIG_SUBDIRS([OMOptim])
 fi
Submodule libraries contains modified content
diff --git a/libraries/Makefile b/libraries/Makefile
index dfbe484..3902960 100644
--- a/libraries/Makefile
+++ b/libraries/Makefile
@@ -1,3 +1,27 @@
+# Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
+# Patch for OpenModelica 1.13.2 (https://www.openmodelica.org)
+#
+# All rights reserved.
+#
+# THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
+# THIS OSMC PUBLIC LICENSE (OSMC-PL) VERSION 1.2.
+# ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE
+# OF THE OSMC PUBLIC LICENSE OR THE GPL VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
+#
+# The OpenModelica software and the Open Source Modelica
+# Consortium (OSMC) Public License (OSMC-PL) are obtained
+# from OSMC, either from the above address,
+# from the URLs: http://www.ida.liu.se/projects/OpenModelica or
+# http://www.openmodelica.org, and in the OpenModelica distribution.
+# GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
+#
+# This program is distributed WITHOUT ANY WARRANTY; without
+# even the implied warranty of  MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH
+# IN THE BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF OSMC-PL.
+#
+# See the full OSMC Public License conditions for more details.
+# SPDX-License-Identifier: GPL-3.0 OR LicenseRef-OSMC-PL
 BUILD_DIR=build/
 OMC=omc
 SVN_DIRS="MSL 3.2.1" "MSL 3.1" "MSL 2.2.2" "MSL 1.6" "Biochem" "NewTables" "Modelica_EmbeddedSystems" "ADGenKinetics" "BondGraph" "Buildings" "IndustrialControlSystems" "LinearMPC" "OpenHydraulics" "RealTimeCoordinationLibrary" "PowerFlow" "EEnStorage" "InstantaneousSymmetricalComponents"
@@ -61,8 +85,8 @@ clean:
 
 check-latest: config.done Makefile.numjobs
 	@echo "Looking for more recent versions of packages"
-	rm -rf build .customBuild
-	mkdir -p build
+	rm -rf $(BUILD_DIR) .customBuild
+	mkdir -p $(BUILD_DIR)
 	./update-library.py -n `cat Makefile.numjobs` --check-latest
 	rm -rf .customBuild
 add-missing: config.done Makefile.numjobs
@@ -119,6 +143,7 @@ rpm: config.done .remote/rpmpool .remote/pool
 upload: config.done .remote/control-files .remote/pool
 	diff -u .remote/nightly-library-files nightly-library-files || (! stat -t debian-build/*.deb >/dev/null 2>&1) || rsync --ignore-existing debian-build/*.deb debian-build/*.tar.gz debian-build/*.tar.xz debian-build/*.dsc "`cat .remote/pool`"
 	scp nightly-library-files nightly-library-sources "`cat .remote/control-files`"
+	`cat .remote/release-command`
 	scp "`cat .remote/control-files`/nightly-library-files" .remote/nightly-library-files
 	scp "`cat .remote/control-files`/nightly-library-sources" .remote/nightly-library-sources
 	./check-debian.sh
@@ -126,52 +151,52 @@ upload-rpm: .remote/rpmpool
 	(! stat -t rpm-build/*.rpm >/dev/null 2>&1) || rsync --ignore-existing rpm-build/*.rpm "`cat .remote/rpmpool`"
 
 Modelica\ 3.2.1.patch:
-	-diff -u -x .svn -x .git -x Library -r git/Modelica/Modelica build/Modelica\ 3.2.1 > "$@.tmp"
+	-diff -u -x .svn -x .git -x Library -r git/MSL/Modelica build/Modelica\ 3.2.1 > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 Modelica\ 1.6.patch:
-	-diff -u -x .svn -x .git -x Library -r "git/Modelica/Modelica 1.6" "build/Modelica 1.6" > "$@.tmp"
+	-diff -u -x .svn -x .git -x Library -r "git/MSL/Modelica 1.6" "build/Modelica 1.6" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 Modelica\ trunk.patch:
-	-diff -u -x .svn -x .git -x Library -r "git/Modelica/Modelica" "build/Modelica trunk" > "$@.tmp"
+	-diff -u -x .svn -x .git -x Library -r "git/MSL/Modelica" "build/Modelica trunk" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 ModelicaTest\ trunk.patch:
-	-diff -u -x .svn -x .git -x Library -r "git/Modelica/ModelicaTest" "build/ModelicaTest trunk" > "$@.tmp"
+	-diff -u -x .svn -x .git -x Library -r "git/MSL/ModelicaTest" "build/ModelicaTest trunk" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 ModelicaServices\ trunk.patch:
-	-diff -u -x .svn -x .git -x Library -r "git/Modelica/ModelicaServices" "build/ModelicaServices trunk" > "$@.tmp"
+	-diff -u -x .svn -x .git -x Library -r "git/MSL/ModelicaServices" "build/ModelicaServices trunk" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 Complex\ trunk.patch:
-	-diff -u "git/Modelica/Complex.mo" "build/Complex trunk.mo" > "$@.tmp"
+	-diff -u "git/MSL/Complex.mo" "build/Complex trunk.mo" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 Modelica\ 3.2.2.patch:
-	-diff -u -x .svn -x .git -x Library -r "git/Modelica/Modelica" "build/Modelica 3.2.2" > "$@.tmp"
+	-diff -u -x .svn -x .git -x Library -r "git/MSL/Modelica" "build/Modelica 3.2.2" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 ModelicaServices\ 3.2.2.patch:
-	-diff -u -w -x .svn -x .git -x Library -r "git/Modelica/ModelicaServices" "build/ModelicaServices 3.2.2" > "$@.tmp"
+	-diff -u -w -x .svn -x .git -x Library -r "git/MSL/ModelicaServices" "build/ModelicaServices 3.2.2" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 Modelica\ 3.2.3.patch:
-	-diff -u -x .svn -x .git -x Library -r "git/Modelica/Modelica" "build/Modelica 3.2.3" > "$@.tmp"
+	-diff -u -x .svn -x .git -x Library -r "git/MSL/Modelica" "build/Modelica 3.2.3" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
 ModelicaServices\ 3.2.3.patch:
-	-diff -u -w -x .svn -x .git -x Library -r "git/Modelica/ModelicaServices" "build/ModelicaServices 3.2.3" > "$@.tmp"
+	-diff -u -w -x .svn -x .git -x Library -r "git/MSL/ModelicaServices" "build/ModelicaServices 3.2.3" > "$@.tmp"
 	sed -i /^Only.in/d "$@.tmp"
 	sed -i 's/^\([+-][+-][+-]\) "\([^"]*\)"/\1 \2/' "$@.tmp"
 	mv "$@.tmp" "$@"
diff --git a/libraries/Makefile.libs b/libraries/Makefile.libs
index 00905be..30f1fe4 100644
--- a/libraries/Makefile.libs
+++ b/libraries/Makefile.libs
@@ -1,722 +1,36 @@
-.PHONY: AdvancedNoise AixLib AlgebraTestSuite ApproxSpline BioChem BondGraph BrineProp BuildSysPro BuildingControlLib BuildingSystems Buildings Chemical DeployStructLib DisHeatLib DriveControl ElectroMechanicalDrives ExternData ExternalMedia ExternalMemoryLib FMITest FailureModes FaultTriggering FeedDriveLibrary FractionalOrder Greenhouses-Library HanserModelica HelmholtzMedia IBPSA IDEAS IndustrialControlSystems KeyWordIO LibRAS LinearMPC MEV ModPowerSystems Modelica Modelica-Arduino Modelica-GNU_ScientificLibrary Modelica-MVEM ModelicaADS ModelicaBook ModelicaCompliance ModelicaDFR Modelica_DeviceDrivers Modelica_LinearSystems2 Modelica_Requirements Modelica_Synchronous MultiPhaseMixtureMedia OpenIPSL Optimisers PNlib PVSystems PhotoVoltaics Physiolibrary Physiomodel PlanarMechanics PowerGrids PowerSystems PowerSystems-latest RealTimeCoordinationLibrary ScalableTestSuite Servomechanisms SolarTherm Soltermica SystemDynamics ThermalSeparation ThermoPower ThermoSysPro VVDRlib VehicleInterfaces WasteWater WindPowerPlants ipsl netCDF-DataReader open-bldc-modelica
-CORE_TARGET=$(BUILD_DIR)/20211001_191033.core
-ALL_TARGET=$(BUILD_DIR)/20211001_191033.all
-CORE_LIBS=BioChem Modelica Modelica_DeviceDrivers Modelica_Synchronous PNlib PowerSystems-latest SystemDynamics ThermoPower ThermoSysPro VVDRlib WasteWater
-OTHER_LIBS=AdvancedNoise AixLib AlgebraTestSuite ApproxSpline BondGraph BrineProp BuildSysPro BuildingControlLib BuildingSystems Buildings Chemical DeployStructLib DisHeatLib DriveControl ElectroMechanicalDrives ExternData ExternalMedia ExternalMemoryLib FMITest FailureModes FaultTriggering FeedDriveLibrary FractionalOrder Greenhouses-Library HanserModelica HelmholtzMedia IBPSA IDEAS IndustrialControlSystems KeyWordIO LibRAS LinearMPC MEV ModPowerSystems Modelica-Arduino Modelica-GNU_ScientificLibrary Modelica-MVEM ModelicaADS ModelicaBook ModelicaCompliance ModelicaDFR Modelica_LinearSystems2 Modelica_Requirements MultiPhaseMixtureMedia OpenIPSL Optimisers PVSystems PhotoVoltaics Physiolibrary Physiomodel PlanarMechanics PowerGrids PowerSystems RealTimeCoordinationLibrary ScalableTestSuite Servomechanisms SolarTherm Soltermica ThermalSeparation VehicleInterfaces WindPowerPlants ipsl netCDF-DataReader open-bldc-modelica
+# Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
+# Patch for OpenModelica 1.13.2 (https://www.openmodelica.org)
+#
+# All rights reserved.
+#
+# THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
+# THIS OSMC PUBLIC LICENSE (OSMC-PL) VERSION 1.2.
+# ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE
+# OF THE OSMC PUBLIC LICENSE OR THE GPL VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
+#
+# The OpenModelica software and the Open Source Modelica
+# Consortium (OSMC) Public License (OSMC-PL) are obtained
+# from OSMC, either from the above address,
+# from the URLs: http://www.ida.liu.se/projects/OpenModelica or
+# http://www.openmodelica.org, and in the OpenModelica distribution.
+# GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
+#
+# This program is distributed WITHOUT ANY WARRANTY; without
+# even the implied warranty of  MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH
+# IN THE BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF OSMC-PL.
+#
+# See the full OSMC Public License conditions for more details.
+# SPDX-License-Identifier: GPL-3.0 OR LicenseRef-OSMC-PL
+.PHONY: MSL
+CORE_TARGET=$(BUILD_DIR)/20160731_190425.core
+ALL_TARGET=$(BUILD_DIR)/20160731_190425.all
+CORE_LIBS=MSL
+OTHER_LIBS=
 ALL_LIBS=$(CORE_LIBS) $(OTHER_LIBS)
 
-TIMESTAMP=20211001_191033
-AdvancedNoise:
-	# Building git/AdvancedNoise
-	./checkout-git.sh 'git/AdvancedNoise' 'https://github.com/modelica-3rdparty/AdvancedNoise.git' 'master' '5ce57acd279dadd0d25b76a6b02d3f9e9d061246'
-	test ! -d 'build//AdvancedNoise 1.0.1'
-	cp -a 'git/AdvancedNoise/AdvancedNoise' "$(BUILD_DIR)/AdvancedNoise 1.0.1"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/AdvancedNoise 1.0.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/AdvancedNoise 1.0.1.license"
-	echo '1.0.1-rc1-3-g5ce57ac' > "$(BUILD_DIR)/AdvancedNoise 1.0.1.last_change"
-AixLib:
-	# Building git/AixLib
-	./checkout-git.sh 'git/AixLib' 'https://github.com/RWTH-EBC/AixLib.git' 'master' '65e49ddf5c935846888a61aa303e52c909619079'
-	test ! -d 'build//AixLib 1.0.0'
-	cp -a 'git/AixLib/AixLib' "$(BUILD_DIR)/AixLib 1.0.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/AixLib 1.0.0.uses"
-	echo 'Modelica_Synchronous 0.92.2' >> "$(BUILD_DIR)/AixLib 1.0.0.uses"
-	echo 'NcDataReader2 2.5.0' >> "$(BUILD_DIR)/AixLib 1.0.0.uses"
-	echo 'Modelica_DeviceDrivers 1.7.0' >> "$(BUILD_DIR)/AixLib 1.0.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/AixLib 1.0.0.license"
-	echo '1.0.0' > "$(BUILD_DIR)/AixLib 1.0.0.last_change"
-	# Building git/AixLib
-	./checkout-git.sh 'git/AixLib' 'https://github.com/RWTH-EBC/AixLib.git' 'v0.4.0' 'v0.4.0'
-	test ! -d 'build//AixLib 0.4.0'
-	cp -a 'git/AixLib/AixLib' "$(BUILD_DIR)/AixLib 0.4.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/AixLib 0.4.0.uses"
-	echo 'Modelica_Synchronous 0.92.1' >> "$(BUILD_DIR)/AixLib 0.4.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/AixLib 0.4.0.license"
-	echo '0.4.0' > "$(BUILD_DIR)/AixLib 0.4.0.last_change"
-AlgebraTestSuite:
-	# Building git/AlgebraTestSuite
-	./checkout-git.sh 'git/AlgebraTestSuite' 'https://github.com/modelica-3rdparty/AlgebraTestSuite.git' 'master' 'b937e1a7f447138c59abec9b2092f84f16bf02e8'
-	test ! -d 'build//AlgebraTestSuite'
-	cp -a 'git/AlgebraTestSuite/AlgebraTestSuite' "$(BUILD_DIR)/AlgebraTestSuite"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/AlgebraTestSuite.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/AlgebraTestSuite.license"
-	echo '20180128-224601~git~master' > "$(BUILD_DIR)/AlgebraTestSuite.last_change"
-ApproxSpline:
-	# Building git/ApproxSpline
-	./checkout-git.sh 'git/ApproxSpline' 'https://github.com/modelica-3rdparty/ApproxSpline.git' 'master' '28420f5c1a88c9cd069defbd8c05e4a78a090675'
-	test ! -d 'build//ApproxSpline 1.0.1'
-	cp -a 'git/ApproxSpline/ApproxSpline' "$(BUILD_DIR)/ApproxSpline 1.0.1"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/ApproxSpline 1.0.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ApproxSpline 1.0.1.license"
-	echo '1.0.1-20210227-210712~git~master' > "$(BUILD_DIR)/ApproxSpline 1.0.1.last_change"
-BioChem:
-	# Building git/BioChem
-	./checkout-git.sh 'git/BioChem' 'https://github.com/OpenModelica/BioChem.git' 'v1.0.2' 'v1.0.2'
-	test ! -d 'build//BioChem 1.0.2'
-	cp -a 'git/BioChem/BioChem' "$(BUILD_DIR)/BioChem 1.0.2"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/BioChem 1.0.2.uses"
-	echo 'mpl2' > "$(BUILD_DIR)/BioChem 1.0.2.license"
-	echo '1.0.2' > "$(BUILD_DIR)/BioChem 1.0.2.last_change"
-BondGraph:
-	# Building git/BondGraph
-	./checkout-git.sh 'git/BondGraph' 'https://github.com/modelica-3rdparty/BondGraph.git' 'master' '20c23e60d12989bd4668ccac47659d82d39d29cc'
-	test ! -f 'build//BondGraph.mo'
-	cp -a 'git/BondGraph/BondGraph.mo' "$(BUILD_DIR)/BondGraph.mo"
-	echo 'Modelica 3.2' >> "$(BUILD_DIR)/BondGraph.uses"
-	echo 'lgpl3+' > "$(BUILD_DIR)/BondGraph.license"
-	echo '20131202-150206~git~master' > "$(BUILD_DIR)/BondGraph.last_change"
-BrineProp:
-	# Building git/BrineProp
-	./checkout-git.sh 'git/BrineProp' 'https://github.com/modelica-3rdparty/BrineProp.git' 'master' '562af7d3498576b5e8d9bfd3b4b11e70774081ba'
-	test ! -d 'build//BrineProp 0.5.6'
-	cp -a 'git/BrineProp/BrineProp' "$(BUILD_DIR)/BrineProp 0.5.6"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/BrineProp 0.5.6.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/BrineProp 0.5.6.license"
-	echo '0.5.6-20210904-124145~git~master' > "$(BUILD_DIR)/BrineProp 0.5.6.last_change"
-BuildSysPro:
-	# Building git/BuildSysPro
-	./checkout-git.sh 'git/BuildSysPro' 'https://github.com/EDF-TREE/BuildSysPro.git' 'v3.3.0' 'v3.3.0'
-	test ! -d 'build//BuildSysPro 3.3.0'
-	cp -a 'git/BuildSysPro/BuildSysPro' "$(BUILD_DIR)/BuildSysPro 3.3.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/BuildSysPro 3.3.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/BuildSysPro 3.3.0.license"
-	echo '3.3.0' > "$(BUILD_DIR)/BuildSysPro 3.3.0.last_change"
-BuildingControlLib:
-	# Building git/BuildingControlLib
-	./checkout-git.sh 'git/BuildingControlLib' 'https://github.com/modelica-3rdparty/BuildingControlLib.git' 'v1.0.0' 'v1.0.0'
-	test ! -d 'build//BuildingControlLib 0.1.0'
-	cp -a 'git/BuildingControlLib/BuildingControlLib' "$(BUILD_DIR)/BuildingControlLib 0.1.0"
-	echo 'AixLib 0.4.0' >> "$(BUILD_DIR)/BuildingControlLib 0.1.0.uses"
-	echo 'Buildings 4.0.0' >> "$(BUILD_DIR)/BuildingControlLib 0.1.0.uses"
-	echo 'Modelica_StateGraph2 2.0.2' >> "$(BUILD_DIR)/BuildingControlLib 0.1.0.uses"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/BuildingControlLib 0.1.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/BuildingControlLib 0.1.0.license"
-	echo '0.1.0-41-gfffe3d8' > "$(BUILD_DIR)/BuildingControlLib 0.1.0.last_change"
-BuildingSystems:
-	# Building git/BuildingSystems
-	./checkout-git.sh 'git/BuildingSystems' 'https://github.com/modelica-3rdparty/BuildingSystems.git' 'master' '41c67bc971fd442b870346fd02a56f560290331e'
-	test ! -d 'build//BuildingSystems 2.0.0-beta'
-	cp -a 'git/BuildingSystems/BuildingSystems' "$(BUILD_DIR)/BuildingSystems 2.0.0-beta"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/BuildingSystems 2.0.0-beta.uses"
-	echo 'NcDataReader2 2.5.0' >> "$(BUILD_DIR)/BuildingSystems 2.0.0-beta.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/BuildingSystems 2.0.0-beta.license"
-	echo '2.0.0-beta2-385-g41c67bc' > "$(BUILD_DIR)/BuildingSystems 2.0.0-beta.last_change"
-Buildings:
-	# Building git/Buildings
-	./checkout-git.sh 'git/Buildings' 'https://github.com/lbl-srg/modelica-buildings.git' 'v6.0.0' 'v6.0.0'
-	test ! -d 'build//Buildings 6.0.0'
-	cp -a 'git/Buildings/Buildings' "$(BUILD_DIR)/Buildings 6.0.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/Buildings 6.0.0.uses"
-	echo 'buildings' > "$(BUILD_DIR)/Buildings 6.0.0.license"
-	echo '6.0.0' > "$(BUILD_DIR)/Buildings 6.0.0.last_change"
-	# Building git/Buildings
-	./checkout-git.sh 'git/Buildings' 'https://github.com/lbl-srg/modelica-buildings.git' 'v7.0.0' 'v7.0.0'
-	test ! -d 'build//Buildings 7.0.0'
-	cp -a 'git/Buildings/Buildings' "$(BUILD_DIR)/Buildings 7.0.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/Buildings 7.0.0.uses"
-	echo 'buildings' > "$(BUILD_DIR)/Buildings 7.0.0.license"
-	echo '7.0.0' > "$(BUILD_DIR)/Buildings 7.0.0.last_change"
-Chemical:
-	# Building git/Chemical
-	./checkout-git.sh 'git/Chemical' 'https://github.com/modelica-3rdparty/Chemical.git' 'master' '5645573fced862430b7b598b4d7ec1a39c7aa0fa'
-	test ! -d 'build//Chemical 1.4.0'
-	cp -a 'git/Chemical/Chemical' "$(BUILD_DIR)/Chemical 1.4.0"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/Chemical 1.4.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Chemical 1.4.0.license"
-	echo '1.4.0-3-g5645573' > "$(BUILD_DIR)/Chemical 1.4.0.last_change"
-DeployStructLib:
-	# Building git/DeployStructLib
-	./checkout-git.sh 'git/DeployStructLib' 'https://github.com/modelica-3rdparty/DeployStructLib.git' 'v1.0' 'v1.0'
-	test ! -d 'build//DeployStructLib'
-	cp -a 'git/DeployStructLib/DeployStructLib' "$(BUILD_DIR)/DeployStructLib"
-	echo '' > "$(BUILD_DIR)/DeployStructLib.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/DeployStructLib.license"
-	echo '20191101-130731~git~v1.0' > "$(BUILD_DIR)/DeployStructLib.last_change"
-DisHeatLib:
-	# Building git/DisHeatLib
-	./checkout-git.sh 'git/DisHeatLib' 'https://github.com/modelica-3rdparty/DisHeatLib.git' 'master' '04573cd6839ca67382cc0b46be0032201a143e2d'
-	test ! -d 'build//DisHeatLib 1.2'
-	cp -a 'git/DisHeatLib/DisHeatLib' "$(BUILD_DIR)/DisHeatLib 1.2"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/DisHeatLib 1.2.uses"
-	echo 'IBPSA 3.0.0' >> "$(BUILD_DIR)/DisHeatLib 1.2.uses"
-	echo 'Buildings 8.0.0' >> "$(BUILD_DIR)/DisHeatLib 1.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/DisHeatLib 1.2.license"
-	echo '1.2-20210819-184615~git~master' > "$(BUILD_DIR)/DisHeatLib 1.2.last_change"
-DriveControl:
-	# Building git/DriveControl
-	./checkout-git.sh 'git/DriveControl' 'https://github.com/AHaumer/DriveControl.git' 'release' 'b7233fd97a92867bb4ec2c3647c7f7e888398644'
-	test ! -d 'build//DriveControl 3.1.0'
-	cp -a 'git/DriveControl/DriveControl' "$(BUILD_DIR)/DriveControl 3.1.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/DriveControl 3.1.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/DriveControl 3.1.0.license"
-	echo '3.1.0-20181117-174044~git~release' > "$(BUILD_DIR)/DriveControl 3.1.0.last_change"
-ElectroMechanicalDrives:
-	# Building git/ElectroMechanicalDrives
-	./checkout-git.sh 'git/ElectroMechanicalDrives' 'https://github.com/christiankral/ElectroMechanicalDrives.git' 'v2.2.0' 'v2.2.0'
-	test ! -d 'build//ElectroMechanicalDrives 2.2.0'
-	cp -a 'git/ElectroMechanicalDrives/ElectroMechanicalDrives' "$(BUILD_DIR)/ElectroMechanicalDrives 2.2.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/ElectroMechanicalDrives 2.2.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ElectroMechanicalDrives 2.2.0.license"
-	echo '2.2.0' > "$(BUILD_DIR)/ElectroMechanicalDrives 2.2.0.last_change"
-ExternData:
-	# Building git/ExternData
-	./checkout-git.sh 'git/ExternData' 'https://github.com/modelica-3rdparty/ExternData.git' 'v2.5.0' 'v2.5.0'
-	test ! -d 'build//ExternData 2.5.0'
-	cp -a 'git/ExternData/ExternData' "$(BUILD_DIR)/ExternData 2.5.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/ExternData 2.5.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ExternData 2.5.0.license"
-	echo '2.5.0' > "$(BUILD_DIR)/ExternData 2.5.0.last_change"
-ExternalMedia:
-	# Building git/ExternalMedia
-	./checkout-git.sh 'git/ExternalMedia' 'https://github.com/modelica/ExternalMedia.git' 'master' '6138312c96142ff3c01190147e6277991bfa2fca'
-ExternalMemoryLib:
-	# Building git/ExternalMemoryLib
-	./checkout-git.sh 'git/ExternalMemoryLib' 'https://github.com/modelica-3rdparty/ExternalMemoryLib.git' 'master' '6488d5815bda23c665123baa916789e283e16d2c'
-	test ! -f 'build//ExternalMemoryLib.mo'
-	cp -a 'git/ExternalMemoryLib/ExternalMemoryLib.mo' "$(BUILD_DIR)/ExternalMemoryLib.mo"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/ExternalMemoryLib.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ExternalMemoryLib.license"
-	echo '20160809-140026~git~master' > "$(BUILD_DIR)/ExternalMemoryLib.last_change"
-FMITest:
-	# Building git/FMITest
-	./checkout-git.sh 'git/FMITest' 'https://github.com/modelica-3rdparty/FMITest.git' 'master' 'a67a276083f4010b249802ad8fc70dc30c09adfd'
-	test ! -d 'build//FMITest'
-	cp -a 'git/FMITest/FMITest' "$(BUILD_DIR)/FMITest"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/FMITest.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/FMITest.license"
-	echo '20181221-112405~git~master' > "$(BUILD_DIR)/FMITest.last_change"
-FailureModes:
-	# Building git/FailureModes
-	./checkout-git.sh 'git/FailureModes' 'https://github.com/modelica-3rdparty/FailureModes.git' 'v1.2.1' 'v1.2.1'
-	test ! -d 'build//FailureModes 1.2.1'
-	cp -a 'git/FailureModes/FailureModes' "$(BUILD_DIR)/FailureModes 1.2.1"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/FailureModes 1.2.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/FailureModes 1.2.1.license"
-	echo '1.2.1' > "$(BUILD_DIR)/FailureModes 1.2.1.last_change"
-FaultTriggering:
-	# Building git/FaultTriggering
-	./checkout-git.sh 'git/FaultTriggering' 'https://github.com/modelica-3rdparty/FaultTriggering.git' 'v0.6.6' 'v0.6.6'
-	test ! -d 'build//FaultTriggering 0.6.6'
-	cp -a 'git/FaultTriggering/FaultTriggering' "$(BUILD_DIR)/FaultTriggering 0.6.6"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/FaultTriggering 0.6.6.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/FaultTriggering 0.6.6.license"
-	echo '0.6.6' > "$(BUILD_DIR)/FaultTriggering 0.6.6.last_change"
-FeedDriveLibrary:
-	# Building git/FeedDriveLibrary
-	./checkout-git.sh 'git/FeedDriveLibrary' 'https://github.com/modelica-3rdparty/FeedDriveLibrary.git' '1.0.1' '1.0.1'
-	test ! -f 'build//FeedDriveLibrary.mo'
-	cp -a 'git/FeedDriveLibrary/FeedDriveLibrary.mo' "$(BUILD_DIR)/FeedDriveLibrary.mo"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/FeedDriveLibrary.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/FeedDriveLibrary.license"
-	echo '20161016-160335~git~1.0.1' > "$(BUILD_DIR)/FeedDriveLibrary.last_change"
-FractionalOrder:
-	# Building git/FractionalOrder
-	./checkout-git.sh 'git/FractionalOrder' 'https://github.com/DLR-SR/FractionalOrder.git' 'master' '99918820e346c362c3ad52d782c8215e5deeac4c'
-	test ! -f 'build//FractionalOrder.mo'
-	cp -a 'git/FractionalOrder/FractionalOrder.mo' "$(BUILD_DIR)/FractionalOrder.mo"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/FractionalOrder.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/FractionalOrder.license"
-	echo '20151007-174822~git~master' > "$(BUILD_DIR)/FractionalOrder.last_change"
-Greenhouses-Library:
-	# Building git/Greenhouses-Library
-	./checkout-git.sh 'git/Greenhouses-Library' 'https://github.com/modelica-3rdparty/Greenhouses-Library.git' 'master' '89ae0e8097eb0751abce2013d304fa5f9c09b885'
-	test ! -d 'build//Greenhouses'
-	cp -a 'git/Greenhouses-Library/Greenhouses' "$(BUILD_DIR)/Greenhouses"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/Greenhouses.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Greenhouses.license"
-	echo '20190802-101414~git~master' > "$(BUILD_DIR)/Greenhouses.last_change"
-HanserModelica:
-	# Building git/HanserModelica
-	./checkout-git.sh 'git/HanserModelica' 'https://github.com/christiankral/HanserModelica.git' 'v1.1.0' 'v1.1.0'
-	test ! -d 'build//HanserModelica 1.1.0'
-	cp -a 'git/HanserModelica/HanserModelica' "$(BUILD_DIR)/HanserModelica 1.1.0"
-	echo 'Complex 3.2.3' >> "$(BUILD_DIR)/HanserModelica 1.1.0.uses"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/HanserModelica 1.1.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/HanserModelica 1.1.0.license"
-	echo '1.1.0' > "$(BUILD_DIR)/HanserModelica 1.1.0.last_change"
-HelmholtzMedia:
-	# Building git/HelmholtzMedia
-	./checkout-git.sh 'git/HelmholtzMedia' 'https://github.com/modelica-3rdparty/HelmholtzMedia.git' 'master' '18ff552ace69672034af2bc8466afef6c374a98a'
-	test ! -d 'build//HelmholtzMedia'
-	cp -a 'git/HelmholtzMedia/HelmholtzMedia' "$(BUILD_DIR)/HelmholtzMedia"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/HelmholtzMedia.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/HelmholtzMedia.license"
-	echo '20210919-135052~git~master' > "$(BUILD_DIR)/HelmholtzMedia.last_change"
-IBPSA:
-	# Building git/IBPSA
-	./checkout-git.sh 'git/IBPSA' 'https://github.com/ibpsa/modelica-ibpsa.git' 'v3.0.0' 'v3.0.0'
-	test ! -d 'build//IBPSA 3.0.0'
-	cp -a 'git/IBPSA/IBPSA' "$(BUILD_DIR)/IBPSA 3.0.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/IBPSA 3.0.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/IBPSA 3.0.0.license"
-	echo '3.0.0' > "$(BUILD_DIR)/IBPSA 3.0.0.last_change"
-IDEAS:
-	# Building git/IDEAS
-	./checkout-git.sh 'git/IDEAS' 'https://github.com/open-ideas/IDEAS.git' 'v2.1.0' 'v2.1.0'
-	test ! -d 'build//IDEAS 2.1.0'
-	cp -a 'git/IDEAS/IDEAS' "$(BUILD_DIR)/IDEAS 2.1.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/IDEAS 2.1.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/IDEAS 2.1.0.license"
-	echo '2.1.0' > "$(BUILD_DIR)/IDEAS 2.1.0.last_change"
-IndustrialControlSystems:
-	# Building git/IndustrialControlSystems
-	./checkout-git.sh 'git/IndustrialControlSystems' 'https://github.com/modelica-3rdparty/IndustrialControlSystems.git' 'v1.1.0' 'v1.1.0'
-	test ! -d 'build//IndustrialControlSystems 1.1.0'
-	cp -a 'git/IndustrialControlSystems/IndustrialControlSystems' "$(BUILD_DIR)/IndustrialControlSystems 1.1.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/IndustrialControlSystems 1.1.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/IndustrialControlSystems 1.1.0.license"
-	echo '1.1.0' > "$(BUILD_DIR)/IndustrialControlSystems 1.1.0.last_change"
-KeyWordIO:
-	# Building git/KeyWordIO
-	./checkout-git.sh 'git/KeyWordIO' 'https://github.com/christiankral/KeyWordIO.git' 'v0.9.0' 'v0.9.0'
-	test ! -d 'build//KeyWordIO 0.9.0'
-	cp -a 'git/KeyWordIO/KeyWordIO' "$(BUILD_DIR)/KeyWordIO 0.9.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/KeyWordIO 0.9.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/KeyWordIO 0.9.0.license"
-	echo '0.9.0' > "$(BUILD_DIR)/KeyWordIO 0.9.0.last_change"
-LibRAS:
-	# Building git/LibRAS
-	./checkout-git.sh 'git/LibRAS' 'https://github.com/FishSim/LibRAS.git' 'master' 'fca9de50a484a2213f3ca1b39e275c237c471688'
-	test ! -d 'build//LibRAS'
-	cp -a 'git/LibRAS/LibRAS' "$(BUILD_DIR)/LibRAS"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/LibRAS.uses"
-	echo 'gpl3' > "$(BUILD_DIR)/LibRAS.license"
-	echo '20190213-093248~git~master' > "$(BUILD_DIR)/LibRAS.last_change"
-LinearMPC:
-	# Building git/LinearMPC
-	./checkout-git.sh 'git/LinearMPC' 'https://github.com/modelica-3rdparty/LinearMPC.git' 'v1.0' 'v1.0'
-	test ! -f 'build//LinearMPC 1.mo'
-	cp -a 'git/LinearMPC/LinearMPC.mo' "$(BUILD_DIR)/LinearMPC 1.mo"
-	echo 'Modelica 3.2' >> "$(BUILD_DIR)/LinearMPC 1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/LinearMPC 1.license"
-	echo '1.0' > "$(BUILD_DIR)/LinearMPC 1.last_change"
-MEV:
-	# Building git/MEV
-	./checkout-git.sh 'git/MEV' 'https://github.com/looms-polimi/MEV.git' 'v1.0.1' 'v1.0.1'
-	test ! -d 'build//MEV 1.0.1'
-	cp -a 'git/MEV/MEV' "$(BUILD_DIR)/MEV 1.0.1"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/MEV 1.0.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/MEV 1.0.1.license"
-	echo '1.0.1' > "$(BUILD_DIR)/MEV 1.0.1.last_change"
-ModPowerSystems:
-	# Building git/ModPowerSystems
-	./checkout-git.sh 'git/ModPowerSystems' 'https://github.com/modelica-3rdparty/ModPowerSystems.git' 'master' 'df3afce27d5e935c4111f392275744a655abe216'
-	test ! -d 'build//ModPowerSystems'
-	cp -a 'git/ModPowerSystems/ModPowerSystems' "$(BUILD_DIR)/ModPowerSystems"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/ModPowerSystems.uses"
-	echo 'Complex 3.2.2' >> "$(BUILD_DIR)/ModPowerSystems.uses"
-	echo 'ModelicaServices 3.2.2' >> "$(BUILD_DIR)/ModPowerSystems.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ModPowerSystems.license"
-	echo '20200324-112731~git~master' > "$(BUILD_DIR)/ModPowerSystems.last_change"
-Modelica:
-	# Building git/Modelica
-	./checkout-git.sh 'git/Modelica' 'https://github.com/OpenModelica/OpenModelica-ModelicaStandardLibrary.git' 'OM/maint/3.2.3' '4a91d52248b0f17415bba1d58881fc730bd94215'
-	test ! -f 'build//Complex 3.2.3.mo'
-	cp -a 'git/Modelica/Complex.mo' "$(BUILD_DIR)/Complex 3.2.3.mo"
-	echo '' > "$(BUILD_DIR)/Complex 3.2.3.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/Complex 3.2.3.license"
-	echo '3.2.3-20210516-174036~git~OM-maint-3.2.3' > "$(BUILD_DIR)/Complex 3.2.3.last_change"
-	test ! -d 'build//Modelica 3.2.3'
-	cp -a 'git/Modelica/Modelica' "$(BUILD_DIR)/Modelica 3.2.3"
-	echo 'Complex 3.2.3' >> "$(BUILD_DIR)/Modelica 3.2.3.uses"
-	echo 'ModelicaServices 3.2.3' >> "$(BUILD_DIR)/Modelica 3.2.3.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/Modelica 3.2.3.license"
-	echo '3.2.3-20210516-174036~git~OM-maint-3.2.3' > "$(BUILD_DIR)/Modelica 3.2.3.last_change"
-	test ! -d 'build//ModelicaServices 3.2.3'
-	cp -a 'git/Modelica/ModelicaServices' "$(BUILD_DIR)/ModelicaServices 3.2.3"
-	echo > "$(BUILD_DIR)/ModelicaServices 3.2.3.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ModelicaServices 3.2.3.license"
-	echo '3.2.3-20210516-174036~git~OM-maint-3.2.3' > "$(BUILD_DIR)/ModelicaServices 3.2.3.last_change"
-	test ! -d 'build//ModelicaTest 3.2.3'
-	cp -a 'git/Modelica/ModelicaTest' "$(BUILD_DIR)/ModelicaTest 3.2.3"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/ModelicaTest 3.2.3.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ModelicaTest 3.2.3.license"
-	echo '3.2.3-20210516-174036~git~OM-maint-3.2.3' > "$(BUILD_DIR)/ModelicaTest 3.2.3.last_change"
-	test ! -f 'build//ObsoleteModelica3 3.2.3.mo'
-	cp -a 'git/Modelica/ObsoleteModelica3.mo' "$(BUILD_DIR)/ObsoleteModelica3 3.2.3.mo"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/ObsoleteModelica3 3.2.3.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ObsoleteModelica3 3.2.3.license"
-	echo '3.2.3-20210516-174036~git~OM-maint-3.2.3' > "$(BUILD_DIR)/ObsoleteModelica3 3.2.3.last_change"
-	test ! -d 'build//ModelicaReference'
-	cp -a 'git/Modelica/ModelicaReference' "$(BUILD_DIR)/ModelicaReference"
-	echo '' > "$(BUILD_DIR)/ModelicaReference.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ModelicaReference.license"
-	echo '20210516-174036~git~OM-maint-3.2.3' > "$(BUILD_DIR)/ModelicaReference.last_change"
-	# Building git/Modelica
-	./checkout-git.sh 'git/Modelica' 'https://github.com/OpenModelica/OpenModelica-ModelicaStandardLibrary.git' 'OM/maint/4.0.x' 'cab27240a4a3ed4ea137226f056bbc0d79543f7a'
-	test ! -f 'build//Complex 4.0.0.mo'
-	cp -a 'git/Modelica/Complex.mo' "$(BUILD_DIR)/Complex 4.0.0.mo"
-	echo '' > "$(BUILD_DIR)/Complex 4.0.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/Complex 4.0.0.license"
-	echo '4.0.0-20210622-131817~git~OM-maint-4.0.x' > "$(BUILD_DIR)/Complex 4.0.0.last_change"
-	test ! -d 'build//Modelica 4.0.0'
-	cp -a 'git/Modelica/Modelica' "$(BUILD_DIR)/Modelica 4.0.0"
-	echo 'Complex 4.0.0' >> "$(BUILD_DIR)/Modelica 4.0.0.uses"
-	echo 'ModelicaServices 4.0.0' >> "$(BUILD_DIR)/Modelica 4.0.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/Modelica 4.0.0.license"
-	echo '4.0.0-20210622-131817~git~OM-maint-4.0.x' > "$(BUILD_DIR)/Modelica 4.0.0.last_change"
-	test ! -d 'build//ModelicaServices 4.0.0'
-	cp -a 'git/Modelica/ModelicaServices' "$(BUILD_DIR)/ModelicaServices 4.0.0"
-	echo > "$(BUILD_DIR)/ModelicaServices 4.0.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ModelicaServices 4.0.0.license"
-	echo '4.0.0-20210622-131817~git~OM-maint-4.0.x' > "$(BUILD_DIR)/ModelicaServices 4.0.0.last_change"
-	test ! -d 'build//ModelicaTest 4.0.0'
-	cp -a 'git/Modelica/ModelicaTest' "$(BUILD_DIR)/ModelicaTest 4.0.0"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/ModelicaTest 4.0.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ModelicaTest 4.0.0.license"
-	echo '4.0.0-20210622-131817~git~OM-maint-4.0.x' > "$(BUILD_DIR)/ModelicaTest 4.0.0.last_change"
-	test ! -f 'build//ObsoleteModelica4 4.0.0.mo'
-	cp -a 'git/Modelica/ObsoleteModelica4.mo' "$(BUILD_DIR)/ObsoleteModelica4 4.0.0.mo"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/ObsoleteModelica4 4.0.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/ObsoleteModelica4 4.0.0.license"
-	echo '4.0.0-20210622-131817~git~OM-maint-4.0.x' > "$(BUILD_DIR)/ObsoleteModelica4 4.0.0.last_change"
-Modelica-Arduino:
-	# Building git/Modelica-Arduino
-	./checkout-git.sh 'git/Modelica-Arduino' 'https://github.com/modelica-3rdparty/Modelica-Arduino.git' 'v0.1.0' 'v0.1.0'
-	test ! -d 'build//Arduino 0.1.0'
-	cp -a 'git/Modelica-Arduino/Arduino' "$(BUILD_DIR)/Arduino 0.1.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/Arduino 0.1.0.uses"
-	echo 'Modelica_DeviceDrivers 1.4.4' >> "$(BUILD_DIR)/Arduino 0.1.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Arduino 0.1.0.license"
-	echo '0.1.0' > "$(BUILD_DIR)/Arduino 0.1.0.last_change"
-Modelica-GNU_ScientificLibrary:
-	# Building git/Modelica-GNU_ScientificLibrary
-	./checkout-git.sh 'git/Modelica-GNU_ScientificLibrary' 'https://github.com/modelica-3rdparty/Modelica-GNU_ScientificLibrary.git' 'master' '9235ab28bdd7f0fe3e7abba48af53d73332858ec'
-	test ! -d 'build//GNU_ScientificLibrary'
-	cp -a 'git/Modelica-GNU_ScientificLibrary/GNU_ScientificLibrary' "$(BUILD_DIR)/GNU_ScientificLibrary"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/GNU_ScientificLibrary.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/GNU_ScientificLibrary.license"
-	echo '20170111-112742~git~master' > "$(BUILD_DIR)/GNU_ScientificLibrary.last_change"
-Modelica-MVEM:
-	# Building git/Modelica-MVEM
-	./checkout-git.sh 'git/Modelica-MVEM' 'https://github.com/modelica-3rdparty/Modelica-MVEM.git' 'v1.0.1' 'v1.0.1'
-	test ! -d 'build//MVEMLib 1.0.1'
-	cp -a 'git/Modelica-MVEM/MVEMLib' "$(BUILD_DIR)/MVEMLib 1.0.1"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/MVEMLib 1.0.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/MVEMLib 1.0.1.license"
-	echo '1.0.1' > "$(BUILD_DIR)/MVEMLib 1.0.1.last_change"
-ModelicaADS:
-	# Building git/ModelicaADS
-	./checkout-git.sh 'git/ModelicaADS' 'https://github.com/modelica-3rdparty/ModelicaADS.git' 'v1.0.1' 'v1.0.1'
-	test ! -d 'build//ModelicaADS'
-	cp -a 'git/ModelicaADS/ModelicaADS' "$(BUILD_DIR)/ModelicaADS"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/ModelicaADS.uses"
-	echo 'AixLib 0.3.0' >> "$(BUILD_DIR)/ModelicaADS.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ModelicaADS.license"
-	echo '20170921-141505~git~v1.0.1' > "$(BUILD_DIR)/ModelicaADS.last_change"
-ModelicaBook:
-	# Building git/ModelicaBook
-	./checkout-git.sh 'git/ModelicaBook' 'https://github.com/xogeny/ModelicaBook.git' 'v0.6.0' 'v0.6.0'
-	test ! -d 'build//ModelicaByExample 0.5.0'
-	cp -a 'git/ModelicaBook/ModelicaByExample' "$(BUILD_DIR)/ModelicaByExample 0.5.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/ModelicaByExample 0.5.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ModelicaByExample 0.5.0.license"
-	echo '0.5.0-154-g6044b75' > "$(BUILD_DIR)/ModelicaByExample 0.5.0.last_change"
-ModelicaCompliance:
-	# Building git/ModelicaCompliance
-	./checkout-git.sh 'git/ModelicaCompliance' 'https://github.com/modelica-compliance/compliance.git' 'master' '8a91e75d8a26acc4de30fc0e5d5e9db83c970bd6'
-	test ! -d 'build//ModelicaCompliance 3.2'
-	cp -a 'git/ModelicaCompliance/ModelicaCompliance' "$(BUILD_DIR)/ModelicaCompliance 3.2"
-	echo '' > "$(BUILD_DIR)/ModelicaCompliance 3.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ModelicaCompliance 3.2.license"
-	echo '3.2-20191002-130415~git~master' > "$(BUILD_DIR)/ModelicaCompliance 3.2.last_change"
-ModelicaDFR:
-	# Building git/ModelicaDFR
-	./checkout-git.sh 'git/ModelicaDFR' 'https://github.com/modelica-3rdparty/ModelicaDFR.git' 'master' '37a441934d05330cf3d13e9ec551954d27eca84c'
-	test ! -f 'build//Nuclear.mo'
-	cp -a 'git/ModelicaDFR/Nuclear.mo' "$(BUILD_DIR)/Nuclear.mo"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/Nuclear.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Nuclear.license"
-	echo '20160806-130022~git~master' > "$(BUILD_DIR)/Nuclear.last_change"
-Modelica_DeviceDrivers:
-	# Building git/Modelica_DeviceDrivers
-	./checkout-git.sh 'git/Modelica_DeviceDrivers' 'https://github.com/modelica/Modelica_DeviceDrivers.git' 'v1.8.2' 'v1.8.2'
-	test ! -d 'build//Modelica_DeviceDrivers 1.8.2'
-	cp -a 'git/Modelica_DeviceDrivers/Modelica_DeviceDrivers' "$(BUILD_DIR)/Modelica_DeviceDrivers 1.8.2"
-	echo 'Modelica_Synchronous 0.92.2' >> "$(BUILD_DIR)/Modelica_DeviceDrivers 1.8.2.uses"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/Modelica_DeviceDrivers 1.8.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Modelica_DeviceDrivers 1.8.2.license"
-	echo '1.8.2' > "$(BUILD_DIR)/Modelica_DeviceDrivers 1.8.2.last_change"
-Modelica_LinearSystems2:
-	# Building git/Modelica_LinearSystems2
-	./checkout-git.sh 'git/Modelica_LinearSystems2' 'https://github.com/modelica/Modelica_LinearSystems2.git' 'v2.3.5' 'v2.3.5'
-	test ! -d 'build//Modelica_LinearSystems2 2.4.0'
-	cp -a 'git/Modelica_LinearSystems2/Modelica_LinearSystems2' "$(BUILD_DIR)/Modelica_LinearSystems2 2.4.0"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/Modelica_LinearSystems2 2.4.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Modelica_LinearSystems2 2.4.0.license"
-	echo '2.4.0-beta.1-2-g1a9735b' > "$(BUILD_DIR)/Modelica_LinearSystems2 2.4.0.last_change"
-Modelica_Requirements:
-	# Building git/Modelica_Requirements
-	./checkout-git.sh 'git/Modelica_Requirements' 'https://github.com/modelica-3rdparty/Modelica_Requirements.git' 'master' 'a427b5cb7997e9036c577d219e6b8a5d0c28389a'
-	test ! -d 'build//Modelica_Requirements 0.6'
-	cp -a 'git/Modelica_Requirements/Modelica_Requirements' "$(BUILD_DIR)/Modelica_Requirements 0.6"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/Modelica_Requirements 0.6.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Modelica_Requirements 0.6.license"
-	echo '0.6-20170818-163012~git~master' > "$(BUILD_DIR)/Modelica_Requirements 0.6.last_change"
-Modelica_Synchronous:
-	# Building git/Modelica_Synchronous
-	./checkout-git.sh 'git/Modelica_Synchronous' 'https://github.com/modelica/Modelica_Synchronous.git' 'master' 'c8350276bfd945086962cf4150ba941b9c57ed13'
-	test ! -d 'build//Modelica_Synchronous 0.93.0'
-	cp -a 'git/Modelica_Synchronous/Modelica_Synchronous' "$(BUILD_DIR)/Modelica_Synchronous 0.93.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/Modelica_Synchronous 0.93.0.uses"
-	echo 'ModelicaServices 3.2.3' >> "$(BUILD_DIR)/Modelica_Synchronous 0.93.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Modelica_Synchronous 0.93.0.license"
-	echo '0.93.0-17-gc835027' > "$(BUILD_DIR)/Modelica_Synchronous 0.93.0.last_change"
-MultiPhaseMixtureMedia:
-	# Building git/MultiPhaseMixtureMedia
-	./checkout-git.sh 'git/MultiPhaseMixtureMedia' 'https://github.com/jwindahlModelon/MultiPhaseMixtureMedia.git' 'master' '0bda0c58af6384f8e0edf7aa7520afb369af3e38'
-OpenIPSL:
-	# Building git/OpenIPSL
-	./checkout-git.sh 'git/OpenIPSL' 'https://github.com/OpenIPSL/OpenIPSL.git' 'v1.5.0' 'v1.5.0'
-	test ! -d 'build//OpenIPSL 1.5.0'
-	cp -a 'git/OpenIPSL/OpenIPSL' "$(BUILD_DIR)/OpenIPSL 1.5.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/OpenIPSL 1.5.0.uses"
-	echo 'Complex 3.2.2' >> "$(BUILD_DIR)/OpenIPSL 1.5.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/OpenIPSL 1.5.0.license"
-	echo '1.5.0' > "$(BUILD_DIR)/OpenIPSL 1.5.0.last_change"
-Optimisers:
-	# Building git/Optimisers
-	./checkout-git.sh 'git/Optimisers' 'https://github.com/modelica-3rdparty/Optimisers.git' 'master' 'e33c69edaad6dad8029167b0ca00533964a6fe37'
-	test ! -d 'build//Optimisers 0.1'
-	cp -a 'git/Optimisers/Optimisers' "$(BUILD_DIR)/Optimisers 0.1"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/Optimisers 0.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Optimisers 0.1.license"
-	echo '0.1-20180116-104125~git~master' > "$(BUILD_DIR)/Optimisers 0.1.last_change"
-PNlib:
-	# Building git/PNlib
-	./checkout-git.sh 'git/PNlib' 'https://github.com/lochel/PNlib.git' 'master' '059545d48dd9ceeccfa3b4e47689ec8dd334dcd8'
-	test ! -d 'build//PNlib 2.2'
-	cp -a 'git/PNlib/PNlib' "$(BUILD_DIR)/PNlib 2.2"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/PNlib 2.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/PNlib 2.2.license"
-	echo '2.2-5-g059545d' > "$(BUILD_DIR)/PNlib 2.2.last_change"
-PVSystems:
-	# Building git/PVSystems
-	./checkout-git.sh 'git/PVSystems' 'https://github.com/modelica-3rdparty/PVSystems.git' 'v0.6.2' 'v0.6.2'
-	test ! -d 'build//PVSystems 0.6.2'
-	cp -a 'git/PVSystems/PVSystems' "$(BUILD_DIR)/PVSystems 0.6.2"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/PVSystems 0.6.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/PVSystems 0.6.2.license"
-	echo '0.6.2' > "$(BUILD_DIR)/PVSystems 0.6.2.last_change"
-PhotoVoltaics:
-	# Building git/PhotoVoltaics
-	./checkout-git.sh 'git/PhotoVoltaics' 'https://github.com/modelica-3rdparty/PhotoVoltaics.git' 'v1.6.0' 'v1.6.0'
-	test ! -d 'build//PhotoVoltaics 1.6.0'
-	cp -a 'git/PhotoVoltaics/PhotoVoltaics' "$(BUILD_DIR)/PhotoVoltaics 1.6.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/PhotoVoltaics 1.6.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/PhotoVoltaics 1.6.0.license"
-	echo '1.6.0' > "$(BUILD_DIR)/PhotoVoltaics 1.6.0.last_change"
-	test ! -d 'build//PhotoVoltaics_TGM 1.6.0'
-	cp -a 'git/PhotoVoltaics/PhotoVoltaics_TGM' "$(BUILD_DIR)/PhotoVoltaics_TGM 1.6.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/PhotoVoltaics_TGM 1.6.0.uses"
-	echo 'Buildings 6.0.0' >> "$(BUILD_DIR)/PhotoVoltaics_TGM 1.6.0.uses"
-	echo 'PhotoVoltaics 1.6.0' >> "$(BUILD_DIR)/PhotoVoltaics_TGM 1.6.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/PhotoVoltaics_TGM 1.6.0.license"
-	echo '1.6.0' > "$(BUILD_DIR)/PhotoVoltaics_TGM 1.6.0.last_change"
-Physiolibrary:
-	# Building git/Physiolibrary
-	./checkout-git.sh 'git/Physiolibrary' 'https://github.com/MarekMatejak/Physiolibrary.git' 'v2.3.1' 'v2.3.1'
-	test ! -d 'build//Physiolibrary 2.3.1'
-	cp -a 'git/Physiolibrary/Physiolibrary' "$(BUILD_DIR)/Physiolibrary 2.3.1"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/Physiolibrary 2.3.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Physiolibrary 2.3.1.license"
-	echo '2.3.1' > "$(BUILD_DIR)/Physiolibrary 2.3.1.last_change"
-Physiomodel:
-	# Building git/Physiomodel
-	./checkout-git.sh 'git/Physiomodel' 'https://github.com/modelica-3rdparty/Physiomodel.git' 'v1.0.0' 'v1.0.0'
-	test ! -d 'build//Physiomodel 1.0.0'
-	cp -a 'git/Physiomodel/Physiomodel' "$(BUILD_DIR)/Physiomodel 1.0.0"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/Physiomodel 1.0.0.uses"
-	echo 'Physiolibrary 2.3.1' >> "$(BUILD_DIR)/Physiomodel 1.0.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Physiomodel 1.0.0.license"
-	echo '1.0.0' > "$(BUILD_DIR)/Physiomodel 1.0.0.last_change"
-PlanarMechanics:
-	# Building git/PlanarMechanics
-	./checkout-git.sh 'git/PlanarMechanics' 'https://github.com/dzimmer/PlanarMechanics.git' 'master' '4818bd6b35baad1fc40182e27e429b2038a21be8'
-	test ! -d 'build//PlanarMechanics 1.5.0'
-	cp -a 'git/PlanarMechanics/PlanarMechanics' "$(BUILD_DIR)/PlanarMechanics 1.5.0"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/PlanarMechanics 1.5.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/PlanarMechanics 1.5.0.license"
-	echo '1.5.0-44-g4818bd6' > "$(BUILD_DIR)/PlanarMechanics 1.5.0.last_change"
-	test ! -d 'build//PlanarMechanicsTest 1.5.0'
-	cp -a 'git/PlanarMechanics/PlanarMechanicsTest' "$(BUILD_DIR)/PlanarMechanicsTest 1.5.0"
-	echo 'Modelica 4.0.0' >> "$(BUILD_DIR)/PlanarMechanicsTest 1.5.0.uses"
-	echo 'PlanarMechanics 1.5.0' >> "$(BUILD_DIR)/PlanarMechanicsTest 1.5.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/PlanarMechanicsTest 1.5.0.license"
-	echo '1.5.0-44-g4818bd6' > "$(BUILD_DIR)/PlanarMechanicsTest 1.5.0.last_change"
-PowerGrids:
-	# Building git/PowerGrids
-	./checkout-git.sh 'git/PowerGrids' 'https://github.com/PowerGrids/PowerGrids.git' 'v1.0.0' 'v1.0.0'
-	test ! -d 'build//PowerGrids 1.0.0'
-	cp -a 'git/PowerGrids/PowerGrids' "$(BUILD_DIR)/PowerGrids 1.0.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/PowerGrids 1.0.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/PowerGrids 1.0.0.license"
-	echo '1.0.0' > "$(BUILD_DIR)/PowerGrids 1.0.0.last_change"
-PowerSystems:
-	# Building git/PowerSystems
-	./checkout-git.sh 'git/PowerSystems' 'https://github.com/modelica/PowerSystems.git' 'v1.0.0' 'v1.0.0'
-	test ! -d 'build//PowerSystems 1.0.0'
-	cp -a 'git/PowerSystems/PowerSystems' "$(BUILD_DIR)/PowerSystems 1.0.0"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/PowerSystems 1.0.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/PowerSystems 1.0.0.license"
-	echo '1.0.0' > "$(BUILD_DIR)/PowerSystems 1.0.0.last_change"
-PowerSystems-latest:
-	# Building git/PowerSystems-latest
-	./checkout-git.sh 'git/PowerSystems-latest' 'https://github.com/modelica/PowerSystems.git' 'master' '78ae47f5ebac19f9600c5d694dc5b634be37dc18'
-	test ! -d 'build//PowerSystems latest'
-	cp -a 'git/PowerSystems-latest/PowerSystems' "$(BUILD_DIR)/PowerSystems latest"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/PowerSystems latest.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/PowerSystems latest.license"
-	echo '20210908-183013~git~master' > "$(BUILD_DIR)/PowerSystems latest.last_change"
-RealTimeCoordinationLibrary:
-	# Building git/RealTimeCoordinationLibrary
-	./checkout-git.sh 'git/RealTimeCoordinationLibrary' 'https://github.com/modelica-3rdparty/RealTimeCoordinationLibrary.git' 'v1.0.2' 'v1.0.2'
-	test ! -d 'build//RealTimeCoordinationLibrary 1.0.2'
-	cp -a 'git/RealTimeCoordinationLibrary' "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2"
-	echo 'Modelica 3.2' >> "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2.uses"
-	echo 'RealTimeCoordinationLibrary 1.0.2' >> "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2.uses"
-	echo 'Modelica_StateGraph2 2.0.1' >> "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2.license"
-	echo '1.0.2' > "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2.last_change"
-	rm -rf "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2/.git"*
-	echo 'Windows-1252' > "$(BUILD_DIR)/RealTimeCoordinationLibrary 1.0.2/package.encoding"
-ScalableTestSuite:
-	# Building git/ScalableTestSuite
-	./checkout-git.sh 'git/ScalableTestSuite' 'https://github.com/casella/ScalableTestSuite.git' 'v1.11.5' 'v1.11.5'
-	test ! -d 'build//ScalableTestSuite 1.11.5'
-	cp -a 'git/ScalableTestSuite/ScalableTestSuite' "$(BUILD_DIR)/ScalableTestSuite 1.11.5"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/ScalableTestSuite 1.11.5.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ScalableTestSuite 1.11.5.license"
-	echo '1.11.5' > "$(BUILD_DIR)/ScalableTestSuite 1.11.5.last_change"
-Servomechanisms:
-	# Building git/Servomechanisms
-	./checkout-git.sh 'git/Servomechanisms' 'https://github.com/modelica-3rdparty/Servomechanisms.git' 'master' '3bf82ba5d3f31b4a0ae05f99ae690037358e153e'
-	test ! -d 'build//Servomechanisms 1.0'
-	cp -a 'git/Servomechanisms/Servomechanisms 1.0' "$(BUILD_DIR)/Servomechanisms 1.0"
-	echo '' > "$(BUILD_DIR)/Servomechanisms 1.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Servomechanisms 1.0.license"
-	echo '1.0-20181206-130737~git~master' > "$(BUILD_DIR)/Servomechanisms 1.0.last_change"
-SolarTherm:
-	# Building git/SolarTherm
-	./checkout-git.sh 'git/SolarTherm' 'https://github.com/SolarTherm/SolarTherm.git' 'master' '91aae31d04f350d0a40a3297e226ab45d00b0ce9'
-	test ! -d 'build//SolarTherm 0.2'
-	cp -a 'git/SolarTherm/SolarTherm' "$(BUILD_DIR)/SolarTherm 0.2"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/SolarTherm 0.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/SolarTherm 0.2.license"
-	echo '0.2-20210923-193911~git~master' > "$(BUILD_DIR)/SolarTherm 0.2.last_change"
-Soltermica:
-	# Building git/Soltermica
-	./checkout-git.sh 'git/Soltermica' 'https://github.com/modelica-3rdparty/Soltermica.git' 'master' '9f7224bd89335f95dffe1ccdaa094df5a3279fdf'
-	test ! -d 'build//Soltermica'
-	cp -a 'git/Soltermica/Soltermica' "$(BUILD_DIR)/Soltermica"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/Soltermica.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/Soltermica.license"
-	echo '20180714-104928~git~master' > "$(BUILD_DIR)/Soltermica.last_change"
-SystemDynamics:
-	# Building git/SystemDynamics
-	./checkout-git.sh 'git/SystemDynamics' 'https://github.com/modelica-3rdparty/SystemDynamics.git' 'master' '2f6bd9382c5aac2aff9148cd9113a418767734b6'
-	test ! -d 'build//SystemDynamics 2.1.1'
-	cp -a 'git/SystemDynamics/SystemDynamics' "$(BUILD_DIR)/SystemDynamics 2.1.1"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/SystemDynamics 2.1.1.uses"
-	echo 'modelica1.1' > "$(BUILD_DIR)/SystemDynamics 2.1.1.license"
-	echo '2.1.1-2-g2f6bd93' > "$(BUILD_DIR)/SystemDynamics 2.1.1.last_change"
-ThermalSeparation:
-	# Building git/ThermalSeparation
-	./checkout-git.sh 'git/ThermalSeparation' 'https://github.com/thom-marx/ThermalSeparation.git' 'master' 'ffa0495ba829ecab105be4bfb3b7652625ec9c03'
-	test ! -d 'build//ThermalSeparation 0.2'
-	cp -a 'git/ThermalSeparation/ThermalSeparation' "$(BUILD_DIR)/ThermalSeparation 0.2"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/ThermalSeparation 0.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ThermalSeparation 0.2.license"
-	echo '0.2-20200823-172857~git~master' > "$(BUILD_DIR)/ThermalSeparation 0.2.last_change"
-ThermoPower:
-	# Building git/ThermoPower
-	./checkout-git.sh 'git/ThermoPower' 'https://github.com/casella/ThermoPower.git' 'master' '650be2c8cbd5abc3535e92b865e509073afc8aeb'
-	test ! -d 'build//ThermoPower 3.1'
-	cp -a 'git/ThermoPower/ThermoPower' "$(BUILD_DIR)/ThermoPower 3.1"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/ThermoPower 3.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ThermoPower 3.1.license"
-	echo '3.1-20210618-101418~git~master' > "$(BUILD_DIR)/ThermoPower 3.1.last_change"
-ThermoSysPro:
-	# Building git/ThermoSysPro
-	./checkout-git.sh 'git/ThermoSysPro' 'https://openmodelica.org/git/ThermoSysPro.git' 'maint/3.1' 'db81ae1b5a6a85f6c6c7693244cafa6087e18ff5'
-	test ! -d 'build//ThermoSysPro 3.1'
-	cp -a 'git/ThermoSysPro/ThermoSysPro' "$(BUILD_DIR)/ThermoSysPro 3.1"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/ThermoSysPro 3.1.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ThermoSysPro 3.1.license"
-	echo '3.1+OSR-18-gdb81ae1' > "$(BUILD_DIR)/ThermoSysPro 3.1.last_change"
-	# Building git/ThermoSysPro
-	./checkout-git.sh 'git/ThermoSysPro' 'https://openmodelica.org/git/ThermoSysPro.git' 'master' '5cef9acb4dedf8af6f4638a4448f08a544ebd30b'
-	test ! -f 'build//TestDerivative.mo'
-	cp -a 'git/ThermoSysPro/TestDerivative.mo' "$(BUILD_DIR)/TestDerivative.mo"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/TestDerivative.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/TestDerivative.license"
-	echo '20191212-010403~git~master' > "$(BUILD_DIR)/TestDerivative.last_change"
-	test ! -f 'build//ThermoSysProLogo.mo'
-	cp -a 'git/ThermoSysPro/ThermoSysProLogo.mo' "$(BUILD_DIR)/ThermoSysProLogo.mo"
-	echo '' > "$(BUILD_DIR)/ThermoSysProLogo.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ThermoSysProLogo.license"
-	echo '20191212-010403~git~master' > "$(BUILD_DIR)/ThermoSysProLogo.last_change"
-	test ! -d 'build//ThermoSysPro 3.2'
-	cp -a 'git/ThermoSysPro/ThermoSysPro' "$(BUILD_DIR)/ThermoSysPro 3.2"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/ThermoSysPro 3.2.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/ThermoSysPro 3.2.license"
-	echo '3.2-20191212-010403~git~master' > "$(BUILD_DIR)/ThermoSysPro 3.2.last_change"
-VVDRlib:
-	# Building git/VVDRlib
-	./checkout-git.sh 'git/VVDRlib' 'https://github.com/lenaRB/VVDRlib.git' 'master' 'eae4981674642eddffc7f2aa3690320fcaddee0e'
-	test ! -d 'build//VVDRlib'
-	cp -a 'git/VVDRlib' "$(BUILD_DIR)/VVDRlib"
-	echo '' > "$(BUILD_DIR)/VVDRlib.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/VVDRlib.license"
-	echo '20170912-142014~git~master' > "$(BUILD_DIR)/VVDRlib.last_change"
-	rm -rf "$(BUILD_DIR)/VVDRlib/.git"*
-VehicleInterfaces:
-	# Building git/VehicleInterfaces
-	./checkout-git.sh 'git/VehicleInterfaces' 'https://github.com/modelica/VehicleInterfaces.git' 'v1.2.5' 'v1.2.5'
-	test ! -d 'build//VehicleInterfaces 1.2.5'
-	cp -a 'git/VehicleInterfaces/VehicleInterfaces' "$(BUILD_DIR)/VehicleInterfaces 1.2.5"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/VehicleInterfaces 1.2.5.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/VehicleInterfaces 1.2.5.license"
-	echo '1.2.5' > "$(BUILD_DIR)/VehicleInterfaces 1.2.5.last_change"
-WasteWater:
-	# Building git/WasteWater
-	./checkout-git.sh 'git/WasteWater' 'https://github.com/modelica-3rdparty/WasteWater.git' 'v2.1.0' 'v2.1.0'
-	test ! -d 'build//WasteWater 2.1.0'
-	cp -a 'git/WasteWater/WasteWater 2.1.0' "$(BUILD_DIR)/WasteWater 2.1.0"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/WasteWater 2.1.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/WasteWater 2.1.0.license"
-	echo '2.1.0' > "$(BUILD_DIR)/WasteWater 2.1.0.last_change"
-WindPowerPlants:
-	# Building git/WindPowerPlants
-	./checkout-git.sh 'git/WindPowerPlants' 'https://github.com/modelica-3rdparty/WindPowerPlants.git' 'v1.2.0' 'v1.2.0'
-	test ! -d 'build//WindPowerPlants 1.2.0'
-	cp -a 'git/WindPowerPlants/WindPowerPlants' "$(BUILD_DIR)/WindPowerPlants 1.2.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/WindPowerPlants 1.2.0.uses"
-	echo 'Complex 3.2.3' >> "$(BUILD_DIR)/WindPowerPlants 1.2.0.uses"
-	echo 'bsd3' > "$(BUILD_DIR)/WindPowerPlants 1.2.0.license"
-	echo '1.2.0' > "$(BUILD_DIR)/WindPowerPlants 1.2.0.last_change"
-ipsl:
-	# Building git/ipsl
-	./checkout-git.sh 'git/ipsl' 'https://github.com/modelica-3rdparty/ipsl.git' 'v1.1.1' 'v1.1.1'
-	test ! -d 'build//iPSL 1.1.0'
-	cp -a 'git/ipsl/iPSL' "$(BUILD_DIR)/iPSL 1.1.0"
-	echo 'Modelica 3.2.1' >> "$(BUILD_DIR)/iPSL 1.1.0.uses"
-	echo 'Complex 3.2.1' >> "$(BUILD_DIR)/iPSL 1.1.0.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/iPSL 1.1.0.license"
-	echo '1.1.0-38-ge0e3ea0' > "$(BUILD_DIR)/iPSL 1.1.0.last_change"
-netCDF-DataReader:
-	# Building git/netCDF-DataReader
-	./checkout-git.sh 'git/netCDF-DataReader' 'https://github.com/modelica-3rdparty/netCDF-DataReader.git' 'v2.5.0' 'v2.5.0'
-	test ! -d 'build//NcDataReader2 2.5.0'
-	cp -a 'git/netCDF-DataReader/NcDataReader2' "$(BUILD_DIR)/NcDataReader2 2.5.0"
-	echo 'Modelica 3.2.3' >> "$(BUILD_DIR)/NcDataReader2 2.5.0.uses"
-	echo 'lgpl2.1+' > "$(BUILD_DIR)/NcDataReader2 2.5.0.license"
-	echo '2.5.0' > "$(BUILD_DIR)/NcDataReader2 2.5.0.last_change"
-open-bldc-modelica:
-	# Building git/open-bldc-modelica
-	./checkout-git.sh 'git/open-bldc-modelica' 'https://github.com/joewa/open-bldc-modelica.git' 'master' '58a83b5b36f267613de4676c95163489b1ddc2e7'
-	test ! -d 'build//OpenBLDC'
-	cp -a 'git/open-bldc-modelica/OpenBLDC' "$(BUILD_DIR)/OpenBLDC"
-	echo 'Modelica 3.2.2' >> "$(BUILD_DIR)/OpenBLDC.uses"
-	echo 'modelica2' > "$(BUILD_DIR)/OpenBLDC.license"
-	echo '20170913-145654~git~master' > "$(BUILD_DIR)/OpenBLDC.last_change"
+MSL:
+	# Building git/MSL
+	cp -ur 'Modelica/Complex.mo' "$(BUILD_DIR)/Complex 3.2.3.mo"
+	cp -ur 'Modelica/Modelica 3.2.3' "$(BUILD_DIR)/"
+	cp -ur 'Modelica/ModelicaServices 3.2.3' "$(BUILD_DIR)/"
