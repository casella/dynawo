within Dynawo.Electrical.Controls.IEC.IEC61400.BaseControls.Auxiliaries;

/*
* Copyright (c) 2022, RTE (http://www.rte-france.com)
* See AUTHORS.txt
* All rights reserved.
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, you can obtain one at http://mozilla.org/MPL/2.0/.
* SPDX-License-Identifier: MPL-2.0
*
* This file is part of Dynawo, an hybrid C++/Modelica open source suite of simulation tools for power systems.
*/

model Measurements "Measurement module for wind turbine controls (IEC NÂ°61400-27-1)"
  extends Dynawo.Electrical.Controls.IEC.BaseClasses.BaseMeasurements;

  //Measurement parameters
  parameter Types.AngularVelocityPu DfMaxPu "Maximum frequency ramp rate in pu/s (base omegaNom)" annotation(
    Dialog(tab = "Measurement"));
  parameter Types.Time tfFilt "Filter time constant for frequency measurement in s" annotation(
    Dialog(tab = "Measurement"));

  //Input variables
  Modelica.Blocks.Interfaces.RealInput omegaRefPu(start = SystemBase.omegaRef0Pu) "Grid angular frequency in pu (base omegaNom)" annotation(
    Placement(visible = true, transformation(origin = {-160, -120}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-110, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  //Output variables
  Modelica.Blocks.Interfaces.RealOutput omegaFiltPu(start = SystemBase.omegaRef0Pu) "Filtered grid angular frequency in pu (base omegaNom)" annotation(
    Placement(visible = true, transformation(origin = {150, -120}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput theta(start = UPhase0) "Phase shift between the converter and the grid rotating frames in rad" annotation(
    Placement(visible = true, transformation(origin = {150, -80}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Interfaces.RealOutput UPu(start = U0Pu) "Voltage amplitude at grid terminal in pu (base UNom)" annotation(
    Placement(visible = true, transformation(origin = {150, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  //Other variables
  Types.CurrentModulePu IWtPu(start = ComplexMath.'abs'(i0Pu) * SystemBase.SnRef / SNom) "Current module at grid terminal in pu (base UNom, SNom)";
  Types.ActivePowerPu PGenNomPu(start = -P0Pu * (SystemBase.SnRef / SNom)) "Active power generated by the converter at grid terminal in pu (base SNom) (generator convention)";
  Types.ActivePowerPu PGenPu(start = -P0Pu) "Active power generated by the converter at grid terminal in pu (base SnRef) (generator convention)";
  Types.ReactivePowerPu QGenNomPu(start = -Q0Pu * (SystemBase.SnRef / SNom)) "Reactive power generated by the converter at grid terminal in pu (base SNom) (generator convention)";
  Types.ReactivePowerPu QGenPu(start = -Q0Pu) "Reactive power generated by the converter at grid terminal in pu (base SnRef) (generator convention)";
  Types.VoltageModulePu UWtPu(start = U0Pu) "Voltage amplitude at grid terminal in pu (base UNom)";

  Modelica.Blocks.Math.Add add annotation(
    Placement(visible = true, transformation(origin = {90, -120}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.FirstOrder firstOrder4(T = tfFilt, y_start = 0) annotation(
    Placement(visible = true, transformation(origin = {30, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Dynawo.NonElectrical.Blocks.NonLinear.RampLimiter rampLimiter(DuMax = DfMaxPu, Y0 = 0, tS = tS) annotation(
    Placement(visible = true, transformation(origin = {-10, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  Modelica.Blocks.Continuous.Derivative derivative(T = tfFilt / 20, k = 1 / SystemBase.omegaNom, x_start = UPhase0) annotation(
    Placement(visible = true, transformation(origin = {-50, -100}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

  //Initial parameters
  parameter Types.ComplexCurrentPu i0Pu "Initial complex current at grid terminal in pu (base UNom, SnRef) (receptor convention)" annotation(
    Dialog(group = "Initialization"));
  parameter Types.ActivePowerPu P0Pu "Initial active power at grid terminal in pu (base SnRef) (receptor convention)" annotation(
    Dialog(tab = "Operating point"));
  parameter Types.ReactivePowerPu Q0Pu "Initial reactive power at grid terminal in pu (base SnRef) (receptor convention)" annotation(
    Dialog(tab = "Operating point"));
  parameter Types.VoltageModulePu U0Pu "Initial voltage amplitude at grid terminal in pu (base UNom)" annotation(
    Dialog(tab = "Operating point"));
  parameter Types.ComplexVoltagePu u0Pu "Initial complex voltage at grid terminal in pu (base UNom)" annotation(
    Dialog(group = "Initialization"));
  parameter Types.Angle UPhase0 "Initial voltage angle at grid terminal in rad" annotation(
    Dialog(tab = "Operating point"));

equation
  UWtPu = ComplexMath.'abs'(uPu);
  IWtPu = ComplexMath.'abs'(iPu);
  PGenNomPu = ComplexMath.real(uPu * ComplexMath.conj(iPu));
  QGenNomPu = ComplexMath.imag(uPu * ComplexMath.conj(iPu));
  PGenPu = PGenNomPu * SNom / SystemBase.SnRef;
  QGenPu = QGenNomPu * SNom / SystemBase.SnRef;
  connect(omegaRefPu, add.u2) annotation(
    Line(points = {{-160, -120}, {-120, -120}, {-120, -126}, {78, -126}}, color = {0, 0, 127}));
  connect(add.y, omegaFiltPu) annotation(
    Line(points = {{102, -120}, {150, -120}}, color = {0, 0, 127}));
  connect(rampLimiter.y, firstOrder4.u) annotation(
    Line(points = {{1, -100}, {18, -100}}, color = {0, 0, 127}));
  connect(firstOrder4.y, add.u1) annotation(
    Line(points = {{42, -100}, {60, -100}, {60, -114}, {78, -114}}, color = {0, 0, 127}));
  connect(derivative.y, rampLimiter.u) annotation(
    Line(points = {{-38, -100}, {-22, -100}}, color = {0, 0, 127}));
  connect(complexToPolar1.len, UPu) annotation(
    Line(points = {{-58, 6}, {40, 6}, {40, 0}, {150, 0}}, color = {0, 0, 127}));
  connect(complexToPolar1.phi, derivative.u) annotation(
    Line(points = {{-58, -6}, {-40, -6}, {-40, -60}, {-80, -60}, {-80, -100}, {-62, -100}}, color = {0, 0, 127}));
  connect(complexToPolar1.phi, theta) annotation(
    Line(points = {{-58, -6}, {20, -6}, {20, -80}, {150, -80}}, color = {0, 0, 127}));

  annotation(
    preferredView = "diagram",
    Diagram(coordinateSystem(extent = {{-140, -140}, {140, 140}})),
    Icon(graphics = {Rectangle(fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid, extent = {{-100, -100}, {100, 100}}), Text(origin = {16, -23}, extent = {{-108, -24}, {76, 10}}, textString = "Module"), Text(origin = {8, 35}, extent = {{-100, -30}, {88, 20}}, textString = "Measurement")}));
end Measurements;
